

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refl1d.profile &mdash; Refl1D v0.6.19 documentation</title>
    <link rel="stylesheet" href="../../_static/haiku-site.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.6.19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js"></script>
    <script type="text/javascript" src="../../_static/theme_extras.js"></script>
    <link rel="top" title="Refl1D v0.6.19 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="../../_static/logo.png" alt="Logo"/><h1 class="heading"><a href="../../index.html">
          <span>Refl1D v0.6.19 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.profile</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for refl1d.profile</h1><div class="highlight"><pre>
<span class="c"># This program is public domain</span>
<span class="c"># Author: Paul Kienzle</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Scattering length density profile.</span>

<span class="sd">In order to render a reflectometry model, the theory function calculator</span>
<span class="sd">renders each layer in the model for each energy in the probe.  For slab</span>
<span class="sd">layers this is easy: just accumulate the slabs, with the 1-\ $\sigma$ Gaussian</span>
<span class="sd">interface width between the slabs.  For freeform or functional layers,</span>
<span class="sd">this is more complicated.  The rendering needs to chop each layer into</span>
<span class="sd">microslabs and evaluate the profile at each of these slabs.</span>

<span class="sd">Example</span>
<span class="sd">-------</span>

<span class="sd">This example sets up a model which uses tanh to transition from</span>
<span class="sd">silicon to gold in 20 |Ang| with 2 |Ang| steps.</span>

<span class="sd">First define the profile, and put in the substrate:</span>

<span class="sd">    &gt;&gt;&gt; S = Microslabs(nprobe=1,dz=2)</span>
<span class="sd">    &gt;&gt;&gt; S.clear()</span>
<span class="sd">    &gt;&gt;&gt; S.append(w=0,rho=2.07)</span>

<span class="sd">Next add the interface.  This uses :meth:`microslabs` to select</span>
<span class="sd">the points at which the interface is evaluated, much like you</span>
<span class="sd">would do when defining your own special layer type.  Note that the</span>
<span class="sd">points Pz are in the center of the micro slabs.  The width of the</span>
<span class="sd">final slab may be different.  You do not need to use fixed width</span>
<span class="sd">microslabs if you can more efficiently represent the profile with</span>
<span class="sd">a smaller number of variable width slabs, but :meth:`contract_profile`</span>
<span class="sd">serves the same purpose with less work on your part.</span>

<span class="sd">    &gt;&gt;&gt; from numpy import tanh</span>
<span class="sd">    &gt;&gt;&gt; Pw,Pz = S.microslabs(20)</span>
<span class="sd">    &gt;&gt;&gt; print &quot;widths = %s ...&quot;%(&quot; &quot;.join(&quot;%g&quot;%v for v in Pw[:5]))</span>
<span class="sd">    widths = 2 2 2 2 2 ...</span>
<span class="sd">    &gt;&gt;&gt; print &quot;centers = %s ...&quot;%(&quot; &quot;.join(&quot;%g&quot;%v for v in Pz[:5]))</span>
<span class="sd">    centers = 1 3 5 7 9 ...</span>
<span class="sd">    &gt;&gt;&gt; rho = (1-tanh((Pz-10)/5))/2*(2.07-4.5)+4.5</span>
<span class="sd">    &gt;&gt;&gt; S.extend(w=Pw, rho=[rho])</span>

<span class="sd">Finally, add the incident medium and see the results.  Note that *rho*</span>
<span class="sd">is a matrix, with one column for each incident energy.  We are only</span>
<span class="sd">using one energy so we only show the first column.</span>

<span class="sd">    &gt;&gt;&gt; S.append(w=0,rho=4.5)</span>
<span class="sd">    &gt;&gt;&gt; print &quot;width = %s ...&quot;%(&quot; &quot;.join(&quot;%g&quot;%v for v in S.w[:5]))</span>
<span class="sd">    width = 0 2 2 2 2 ...</span>
<span class="sd">    &gt;&gt;&gt; print &quot;rho = %s ...&quot;%(&quot; &quot;.join(&quot;%.2f&quot;%v for v in S.rho[0,:5]))</span>
<span class="sd">    rho = 2.07 2.13 2.21 2.36 2.63 ...</span>

<span class="sd"> Since *irho* and *sigma* were not specified, they will be zero.</span>

<span class="sd">    &gt;&gt;&gt; print &quot;sigma = %s ...&quot;%(&quot; &quot;.join(&quot;%g&quot;%v for v in S.sigma[:5]))</span>
<span class="sd">    sigma = 0 0 0 0 0 ...</span>
<span class="sd">    &gt;&gt;&gt; print &quot;irho = %s ...&quot;%(&quot; &quot;.join(&quot;%g&quot;%v for v in S.irho[0,:5]))</span>
<span class="sd">    irho = 0 0 0 0 0 ...</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">inf</span>
<span class="kn">from</span> <span class="nn">.reflmodule</span> <span class="kn">import</span> <span class="n">_contract_by_area</span><span class="p">,</span> <span class="n">_contract_mag</span>
<span class="kn">from</span> <span class="nn">.reflectivity</span> <span class="kn">import</span> <span class="n">erf</span>
<span class="c">#from scipy.special import erf</span>

<div class="viewcode-block" id="Microslabs"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs">[docs]</a><span class="k">class</span> <span class="nc">Microslabs</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manage the micro slab representation of a model.</span>

<span class="sd">    In order to compute reflectivity, we need a series of slabs with thickness,</span>
<span class="sd">    roughness and scattering potential for each slab.  Because scattering</span>
<span class="sd">    potentials are probe dependent we store an array of potentials for each</span>
<span class="sd">    probe value.</span>

<span class="sd">    Some slab models use non-uniform layers, and so need the additional</span>
<span class="sd">    parameter of dz for the step size within the layer.</span>

<span class="sd">    The space for the slabs is saved even after reset, in preparation for a</span>
<span class="sd">    new set of slabs from different fitting parameters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nprobe</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="mf">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="c"># _slabs contains the 1D objects w, sigma of len n</span>
        <span class="c"># _slabs_rho contains 2D objects rho, irho, with one for each wavelength</span>
        <span class="c"># _slabs_mag contains 1D objects w, sigma, rho, theta of length nmag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="n">nprobe</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="n">dz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_offset</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magnetic_sections</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Microslabs.microslabs"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.microslabs">[docs]</a>    <span class="k">def</span> <span class="nf">microslabs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of microslabs for a layer of the given *thickness*.</span>

<span class="sd">        The step size slabs.dz was defined when the Microslabs</span>
<span class="sd">        object was created.</span>

<span class="sd">        This is a convenience function.  Layer definitions can choose</span>
<span class="sd">        their own slices so long as the step size is approximately</span>
<span class="sd">        slabs.dz in the varying region.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *thickness* : float | A</span>
<span class="sd">                Layer thickness</span>
<span class="sd">        :Returns:</span>
<span class="sd">            *widths*: vector | A</span>
<span class="sd">                Microslab widths</span>
<span class="sd">            *centers*: vector | A</span>
<span class="sd">                Microslab centers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: force dz onto a common boundary to avoid remeshing</span>
        <span class="c"># in the smooth profile function</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="n">thickness</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">edges</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thickness</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mf">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mf">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">widths</span><span class="p">,</span> <span class="n">centers</span>
</div>
<div class="viewcode-block" id="Microslabs.clear"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the slab model so that none are present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magnetic_sections</span> <span class="o">=</span> <span class="p">[]</span>
</div>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span>

<div class="viewcode-block" id="Microslabs.repeat"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mf">1</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the model so that there are *count* versions of the slabs</span>
<span class="sd">        from *start* to the final slab.</span>

<span class="sd">        This is equivalent to L.extend(L[start:]*(count-1)) for list L.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># For now use the dumb implementation; a better implementation</span>
        <span class="c"># would remember the repeats and pre-calculate the matrix product</span>
        <span class="c"># for the repeating region, saving much work later.  This has</span>
        <span class="c"># to work in conjunction with interfaces and with magnetic profiles.</span>
        <span class="n">repeats</span> <span class="o">=</span> <span class="n">count</span><span class="o">-</span><span class="mf">1</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span>
        <span class="n">fromidx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
        <span class="n">toidx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="n">end</span><span class="o">+</span><span class="n">repeats</span><span class="o">*</span><span class="n">length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve</span><span class="p">(</span><span class="n">repeats</span><span class="o">*</span><span class="n">length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="n">toidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="n">fromidx</span><span class="p">],[</span><span class="n">repeats</span><span class="p">,</span><span class="mf">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[</span><span class="n">toidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[</span><span class="n">fromidx</span><span class="p">],[</span><span class="n">repeats</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">+=</span> <span class="n">repeats</span><span class="o">*</span><span class="n">length</span>

        <span class="c"># Replace interface on the top</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interface</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magnetic_sections</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Repeated magnetic layers not implemented&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_reserve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nadd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reserve space for at least *nadd* slabs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ns</span><span class="p">,</span><span class="n">nl</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">ns</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">+</span> <span class="n">nadd</span><span class="p">:</span>
            <span class="n">new_ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">+</span> <span class="n">nadd</span> <span class="o">+</span> <span class="mf">50</span>
            <span class="c"># TODO: what&#39;s with the sudden need for refcheck?  Is someone</span>
            <span class="c"># else holding a reference to the array?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">new_ns</span><span class="p">,</span> <span class="mf">4</span><span class="p">),</span> <span class="n">refcheck</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">new_ns</span><span class="p">,</span> <span class="n">nl</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="n">refcheck</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<div class="viewcode-block" id="Microslabs.extend"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">irho</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the micro slab model with the given layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nadd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve</span><span class="p">(</span><span class="n">nadd</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="o">+</span><span class="n">nadd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">+=</span> <span class="n">nadd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[</span><span class="n">idx</span><span class="p">,:,</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[</span><span class="n">idx</span><span class="p">,:,</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">irho</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</div>
<div class="viewcode-block" id="Microslabs.append"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">irho</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the micro slab model with a single layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#self.extend(w=[w],sigma=[sigma],rho=[rho],irho=[irho])</span>
        <span class="c">#return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,:,</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,:,</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">irho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">+=</span> <span class="mf">1</span>
</div>
<div class="viewcode-block" id="Microslabs.add_magnetism"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.add_magnetism">[docs]</a>    <span class="k">def</span> <span class="nf">add_magnetism</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchor</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">rhoM</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">thetaM</span><span class="o">=</span><span class="mf">270.</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add magnetic layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Keep the magnetic sections until the end</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span> <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magnetic_sections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">w</span><span class="p">,</span><span class="n">rhoM</span><span class="p">,</span><span class="n">thetaM</span><span class="p">)),</span>
                                        <span class="n">anchor</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Microslabs.thickness"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.thickness">[docs]</a>    <span class="k">def</span> <span class="nf">thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total thickness of the profile.</span>

<span class="sd">        Note that thickness includes the thickness of the substrate and</span>
<span class="sd">        surface layers.  Normally these will be zero, but the contract</span>
<span class="sd">        profile operation may result in large values for either.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="mf">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,</span><span class="mf">0</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Microslabs.interface"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.interface">[docs]</a>    <span class="k">def</span> <span class="nf">interface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interfaces act to smear the microslabs after the fact.  This</span>
<span class="sd">        allows more flexibility than trying to compute the effects</span>
<span class="sd">        of roughness on non-flat layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;special interfaces not yet supported&#39;</span><span class="p">)</span>
        <span class="c"># TODO: check that Nevot-Croce works between microslab sections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mf">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">],</span> <span class="n">irho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Microslabs.w"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.w">[docs]</a>    <span class="k">def</span> <span class="nf">w</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Thickness (A)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Microslabs.sigma"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.sigma">[docs]</a>    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;rms roughness (A)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">]</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Microslabs.surface_sigma"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.surface_sigma">[docs]</a>    <span class="k">def</span> <span class="nf">surface_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;sigma above the surface (which is not part of sigma)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Microslabs.rho"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Scattering length density (10^-6 number density)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,:,</span><span class="mf">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Microslabs.irho"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.irho">[docs]</a>    <span class="k">def</span> <span class="nf">irho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Absorption (10^-6 number density)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slabs_rho</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">,:,</span><span class="mf">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Microslabs.ismagnetic"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.ismagnetic">[docs]</a>    <span class="k">def</span> <span class="nf">ismagnetic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magnetic_sections</span> <span class="o">!=</span> <span class="p">[]</span>
</div>
<div class="viewcode-block" id="Microslabs.finalize"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.finalize">[docs]</a>    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step_interfaces</span><span class="p">,</span> <span class="n">dA</span><span class="p">,</span> <span class="n">roughness_limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rendering complete.</span>

<span class="sd">        Call this method after the microslab model has been constructed,</span>
<span class="sd">        so any post-rendering processes can be completed.</span>

<span class="sd">        In addition to clearing any width from the substrate and</span>
<span class="sd">        the surface surround, this will align magnetic and nuclear slabs,</span>
<span class="sd">        convert interfaces to step interfaces if desired, and merge slabs</span>
<span class="sd">        with similar scattering potentials to reduce computation time.</span>

<span class="sd">        *step_interfaces* is True if interfaces should be rendered using</span>
<span class="sd">        slabs.</span>

<span class="sd">        *dA* is the tolerance to use when deciding if similar layers can</span>
<span class="sd">        be merged.</span>

<span class="sd">        *roughness_limit* is the maximum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limited_sigma</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">roughness_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ismagnetic</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_render_magnetic</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contract_magnetic</span><span class="p">(</span><span class="n">dA</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">step_interfaces</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_render_interfaces</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contract_profile</span><span class="p">(</span><span class="n">dA</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contract_profile</span><span class="p">(</span><span class="n">dA</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_render_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert all interfaces into step interfaces by sampling the</span>
<span class="sd">        analytic version of the smoothed profile at intervals of dz.</span>

<span class="sd">        The interface effects are limited to the surrounding layers.</span>

<span class="sd">        Use of contract_profile afterward is strongly recommended, for</span>
<span class="sd">        better performance on models with large sections of constant</span>
<span class="sd">        scattering potential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">irho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_smooth_profile</span><span class="p">(</span><span class="n">dz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c"># TODO: doesn&#39;t handle multiple wavelength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">irho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_offset</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
        <span class="c">#print &quot;z_offset&quot;, self._z_offset</span>

    <span class="k">def</span> <span class="nf">_contract_magnetic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dA</span><span class="p">):</span>
        <span class="c"># TODO: do we want to use common boundaries for all lambda?</span>
        <span class="c"># TODO: don&#39;t throw away other wavelengths</span>
        <span class="k">if</span> <span class="n">dA</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">w</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span><span class="p">,</span><span class="n">rhoM</span><span class="p">,</span><span class="n">thetaM</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">rhoM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaM</span><span class="p">]</span>
        <span class="c">#print &quot;final sld before contract&quot;,rho[-1]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_contract_mag</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span><span class="p">,</span><span class="n">rhoM</span><span class="p">,</span><span class="n">thetaM</span><span class="p">,</span><span class="n">dA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhoM</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thetaM</span> <span class="o">=</span> <span class="n">thetaM</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="c">#print &quot;final sld after contract&quot;,rho[n-1],self.rho[0][n-1],n</span>

    <span class="k">def</span> <span class="nf">_contract_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dA</span><span class="p">):</span>
        <span class="c"># TODO: do we want to use common boundaries for all lambda?</span>
        <span class="c"># TODO: don&#39;t throw away other wavelengths</span>
        <span class="k">if</span> <span class="n">dA</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">w</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">]]</span>
        <span class="c">#print &quot;final sld before contract&quot;,rho[-1]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_contract_by_area</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span><span class="p">,</span><span class="n">dA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_slabs</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[:</span><span class="n">n</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
        <span class="c">#print &quot;final sld after contract&quot;,rho[n-1],self.rho[0][n-1],n</span>

    <span class="k">def</span> <span class="nf">_DEAD_apply_smoothness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dA</span><span class="p">,</span> <span class="n">smoothness</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a guassian interface for layers which have been coalesced using</span>
<span class="sd">        the contract_profile function.</span>

<span class="sd">        Note that we guess which interfaces this applies to after the fact</span>
<span class="sd">        using criteria similar to those used to coalesce the microslabs</span>
<span class="sd">        into layers, and so it may apply to layers which are close in</span>
<span class="sd">        scattering length density and have zero sigma, but which were</span>
<span class="sd">        distinct in the original model.  The displayed profile will show</span>
<span class="sd">        the profile used to calculate the reflectivity, so even though</span>
<span class="sd">        this behaviour is different from what the user intended, the</span>
<span class="sd">        result will not be misleading.</span>

<span class="sd">        In a detailed example of a tethered polymer model, smoothness</span>
<span class="sd">        was found to be worse than no smoothness, so this function has</span>
<span class="sd">        been removed from the execution stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dA</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">smoothness</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span> <span class="k">return</span>
        <span class="c">#TODO: refine this so that it can look forward as well as back</span>
        <span class="c">#TODO: also need to avoid changing explicit sigma=0...</span>
        <span class="n">w</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">irho</span><span class="p">)))</span>
        <span class="n">step</span><span class="p">[:</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[</span><span class="mf">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>  <span class="c"># compute dA of step; substrate uses w=1</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sigma</span><span class="o">==</span><span class="mf">0</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">3</span><span class="o">*</span><span class="n">dA</span>
        <span class="n">sigma</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">fix</span><span class="p">]]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">fix</span><span class="p">]]</span><span class="o">*</span><span class="n">smoothness</span>

    <span class="k">def</span> <span class="nf">_limited_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the roughness limited by layer thickness.</span>

<span class="sd">        *limit* is the number of times sigma has to fit in the layers</span>
<span class="sd">        on either side of the interface.  The returned sigma is</span>
<span class="sd">        truncated to min(wlo,whi)/*limit* where wlo is the thickness</span>
<span class="sd">        of the layer below the interface, and whi is the  thickness above</span>
<span class="sd">        the interface.  A *limit* value of 0 returns the original sigma.</span>

<span class="sd">        The interface calculation only smears an interface across one</span>
<span class="sd">        layer.  This can lead to artifacts with large roughness, and</span>
<span class="sd">        a difference between the reflectivity computed from the smooth</span>
<span class="sd">        profile and that computed from the step profile and Nevot-Croce</span>
<span class="sd">        analytic roughness.  To remove the artifact and make the values</span>
<span class="sd">        consistent, the profile can be computed with roughness limited</span>
<span class="sd">        by surrounding layer thickness.  A *limit* value of 3 yields</span>
<span class="sd">        calculated reflectivity that is indistinguishable up to Qz</span>
<span class="sd">        determined by profile step size dz.  Below this value artifacts</span>
<span class="sd">        can occur when roughness is large.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">compute_limited_sigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

<div class="viewcode-block" id="Microslabs.step_profile"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.step_profile">[docs]</a>    <span class="k">def</span> <span class="nf">step_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a step profile representation of the microslab structure.</span>

<span class="sd">        Nevot-Croce interfaces are not represented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">,:]]</span><span class="o">*</span><span class="mf">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">irho</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">,:]]</span><span class="o">*</span><span class="mf">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">2</span><span class="p">:</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="mf">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="mf">10</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">ws</span><span class="p">]),</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mf">0</span><span class="p">,</span><span class="n">ws</span><span class="p">,</span><span class="n">ws</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span><span class="o">+</span><span class="mf">10</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">10</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">z</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_z_offset</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span>
</div>
<div class="viewcode-block" id="Microslabs.smooth_profile"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.smooth_profile">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dz</span><span class="o">=</span><span class="mf">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a smooth profile representation of the microslab structure</span>

<span class="sd">        Nevot-Croce roughness is approximately represented, though the</span>
<span class="sd">        calculation is incorrect for layers with large roughness compared</span>
<span class="sd">        to the thickness.</span>

<span class="sd">        The returned profile has uniform step size *dz*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_smooth_profile</span><span class="p">(</span><span class="n">dz</span><span class="o">=</span><span class="n">dz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_z_offset</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span>
</div>
<div class="viewcode-block" id="Microslabs.magnetic_profile"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.Microslabs.magnetic_profile">[docs]</a>    <span class="k">def</span> <span class="nf">magnetic_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a profile representation of the magnetic microslab structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_profile</span><span class="p">()</span>
        <span class="n">rhoM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rhoM</span><span class="p">]</span><span class="o">*</span><span class="mf">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">thetaM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaM</span><span class="p">]</span><span class="o">*</span><span class="mf">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span><span class="p">,</span><span class="n">rhoM</span><span class="p">,</span><span class="n">thetaM</span>
</div>
    <span class="k">def</span> <span class="nf">_render_magnetic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render nuclear and magnetic profiles on common slab boundaries.</span>

<span class="sd">        Creates rhoM and thetaM columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: do we need to worry about magnetism bleeding into the</span>
        <span class="c"># substrate or the surface surround.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_render_interfaces</span><span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_z_offset</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>

        <span class="c"># Fill in gaps for magnetic profile</span>
        <span class="n">wM</span><span class="p">,</span> <span class="n">rhoM</span><span class="p">,</span> <span class="n">thetaM</span><span class="p">,</span> <span class="n">sigmaM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_magnetic_sections</span><span class="p">()</span>

        <span class="n">rhoM</span> <span class="o">=</span> <span class="n">build_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">wM</span><span class="p">,</span> <span class="n">sigmaM</span><span class="p">,</span> <span class="n">rhoM</span><span class="p">)</span>
        <span class="n">thetaM</span> <span class="o">=</span> <span class="n">build_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">wM</span><span class="p">,</span> <span class="n">sigmaM</span><span class="p">,</span> <span class="n">thetaM</span><span class="p">)</span>
        <span class="c">#print [len(v) for v in w, rho, irho, rhoM, thetaM]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rhoM</span> <span class="o">=</span> <span class="n">rhoM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thetaM</span> <span class="o">=</span> <span class="n">thetaM</span>

    <span class="k">def</span> <span class="nf">_join_magnetic_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert anchored magnetic sections into coarse magnetic slabs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Find the magnetic blocks</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">sigmas</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_magnetic_sections</span><span class="p">)</span>

        <span class="c"># Splice the blocks together with rhoM_gap=0 and</span>
        <span class="c"># thetaM_gap=(thetaM_below+thetaM_above)/2.</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">0</span><span class="p">],[</span><span class="mf">0</span><span class="p">],[</span><span class="n">blocks</span><span class="p">[</span><span class="mf">0</span><span class="p">][</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">]]]]</span>
        <span class="n">interfaces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">B</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">blocks</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">:</span> <span class="c"># Big gap, so need spacer</span>
                <span class="c"># Target average theta between blocks.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
                    <span class="n">thetaM</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
                    <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thetaM</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">][</span><span class="mf">2</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>
                    <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">][</span><span class="mf">1</span><span class="p">])</span>
                <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">w</span><span class="p">],[</span><span class="mf">0</span><span class="p">],[</span><span class="n">thetaM</span><span class="p">]])</span>
                <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mf">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-6</span><span class="p">:</span> <span class="c"># Small gap, so add it to the start of the next block</span>
                <span class="n">B</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
                    <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmas</span><span class="p">[</span><span class="mf">0</span><span class="p">][</span><span class="mf">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Average the sigmas between blocks which are connected</span>
                    <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">][</span><span class="mf">1</span><span class="p">]</span><span class="o">+</span><span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mf">0</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># negative gap should never happen</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Overlapping magnetic layers at </span><span class="si">%d</span><span class="s">&quot;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">nslabs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mf">0</span><span class="p">,:])</span>
            <span class="n">interfaces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">nslabs</span><span class="o">-</span><span class="mf">1</span><span class="p">))</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mf">0</span><span class="p">,:])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">width</span>

        <span class="c"># Add the final slice</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span><span class="p">()</span> <span class="o">-</span> <span class="n">pos</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">][</span><span class="mf">2</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">w</span><span class="p">],[</span><span class="mf">0</span><span class="p">],[</span><span class="n">theta</span><span class="p">]])</span>
        <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmas</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">][</span><span class="mf">1</span><span class="p">])</span>

        <span class="n">wM</span><span class="p">,</span><span class="n">rhoM</span><span class="p">,</span><span class="n">thetaM</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">slices</span><span class="p">)]</span>
        <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interfaces</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wM</span><span class="p">,</span><span class="n">rhoM</span><span class="p">,</span><span class="n">thetaM</span><span class="p">,</span><span class="n">sigmaM</span>

    <span class="k">def</span> <span class="nf">_build_smooth_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dz</span><span class="p">):</span>
        <span class="n">thickness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span><span class="p">()</span>
        <span class="n">left</span>  <span class="o">=</span> <span class="mf">0</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">*</span><span class="mf">3</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">thickness</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span><span class="o">*</span><span class="mf">3</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="o">+</span><span class="n">dz</span><span class="p">,</span><span class="n">dz</span><span class="p">)</span>
        <span class="c"># Only show the first wavelength</span>
        <span class="n">rho</span>  <span class="o">=</span> <span class="n">build_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
        <span class="n">irho</span> <span class="o">=</span> <span class="n">build_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irho</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">irho</span>

</div>
<div class="viewcode-block" id="compute_limited_sigma"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.compute_limited_sigma">[docs]</a><span class="k">def</span> <span class="nf">compute_limited_sigma</span><span class="p">(</span><span class="n">thickness</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="c"># Limit roughness to the depths of the surrounding layers.  Roughness</span>
    <span class="c"># of the first and last layers interfaces is limited only by the</span>
    <span class="c"># depth of the first and last layers.  We must check explicitly for</span>
    <span class="c"># a pure substrate system since that has no limits on roughness.</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="o">&gt;</span> <span class="mf">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">thickness</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">2</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">thickness</span><span class="p">[:</span><span class="o">-</span><span class="mf">1</span><span class="p">],</span><span class="n">thickness</span><span class="p">[</span><span class="mf">1</span><span class="p">:]),</span><span class="n">axis</span><span class="o">=</span><span class="mf">0</span><span class="p">)</span><span class="o">/</span><span class="n">limit</span>
        <span class="n">s</span><span class="p">[</span> <span class="mf">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">thickness</span><span class="p">[</span> <span class="mf">1</span><span class="p">]</span><span class="o">/</span><span class="n">limit</span>
        <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thickness</span><span class="p">[</span><span class="o">-</span><span class="mf">2</span><span class="p">]</span><span class="o">/</span><span class="n">limit</span>
        <span class="n">roughness</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">roughness</span><span class="o">&lt;</span><span class="n">s</span><span class="p">,</span><span class="n">roughness</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">roughness</span>

</div>
<div class="viewcode-block" id="build_mag_profile"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.build_mag_profile">[docs]</a><span class="k">def</span> <span class="nf">build_mag_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">blends</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert magnetic segments to a smooth profile.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># TODO this could be faster since we don&#39;t need to blend initially.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mf">0</span><span class="o">*</span><span class="n">z</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">build_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="build_profile"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.build_profile">[docs]</a><span class="k">def</span> <span class="nf">build_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">roughness</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a step profile to a smooth profile.</span>

<span class="sd">    *z*          calculation points</span>
<span class="sd">    *thickness*  thickness of the layers (first and last values ignored)</span>
<span class="sd">    *roughness*  roughness of the interfaces (one less than d)</span>
<span class="sd">    *value*      profile being computed</span>
<span class="sd">    *max_rough*  limit the roughness to a fraction of the layer thickness</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Find interface depths</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">thickness</span><span class="p">[</span><span class="mf">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1</span><span class="p">]),</span> <span class="n">inf</span><span class="p">)</span> <span class="p">)</span>

    <span class="c"># gives the layer boundaries in terms of the index of the z</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
    <span class="c"># TODO: The following hack makes sure the final z value is calculated.</span>
    <span class="c"># TODO: Make sure it works even when z is wider than the range of offsets.</span>
    <span class="k">if</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="c"># compute the results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mvalue</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mf">0</span><span class="p">:</span>
            <span class="n">lsigma</span> <span class="o">=</span> <span class="n">lvalue</span> <span class="o">=</span> <span class="n">lblend</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lsigma</span> <span class="o">=</span> <span class="n">roughness</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
            <span class="n">lvalue</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
            <span class="n">lblend</span> <span class="o">=</span> <span class="n">blend</span><span class="p">(</span><span class="n">zo</span><span class="o">-</span><span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">lsigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">-</span><span class="mf">1</span><span class="p">:</span>
            <span class="n">rsigma</span> <span class="o">=</span> <span class="n">rvalue</span> <span class="o">=</span> <span class="n">rblend</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rsigma</span> <span class="o">=</span> <span class="n">roughness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rvalue</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span>
            <span class="n">rblend</span> <span class="o">=</span> <span class="n">blend</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span><span class="o">-</span><span class="n">zo</span><span class="p">,</span><span class="n">rsigma</span><span class="p">)</span>
        <span class="c">#print &quot;zo&quot;,i,zo</span>
        <span class="c">#print &quot;lblend&quot;,lsigma,lblend</span>
        <span class="c">#print &quot;rblend&quot;,rsigma,rblend</span>
        <span class="n">mblend</span> <span class="o">=</span> <span class="mf">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">lblend</span><span class="o">+</span><span class="n">rblend</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mvalue</span><span class="o">*</span><span class="n">mblend</span> <span class="o">+</span> <span class="n">lvalue</span><span class="o">*</span><span class="n">lblend</span> <span class="o">+</span> <span class="n">rvalue</span><span class="o">*</span><span class="n">rblend</span>
        <span class="c">#result[idx[i]:idx[i+1]] = rvalue*rblend</span>

    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="blend"><a class="viewcode-back" href="../../api/profile.html#refl1d.profile.blend">[docs]</a><span class="k">def</span> <span class="nf">blend</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">rough</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    blend function</span>

<span class="sd">    Given a Gaussian roughness value, compute the portion of the neighboring</span>
<span class="sd">    profile you expect to find in the current profile at depth z.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rough</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mf">0</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">erf</span><span class="p">(</span> <span class="n">z</span><span class="o">/</span><span class="p">(</span> <span class="n">rough</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span></div>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2006-2011, Paul Kienzle, Nikunj Patel, James Krycka.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>