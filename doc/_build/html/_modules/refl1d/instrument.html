

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refl1d.instrument &mdash; Refl1D v0.6.19 documentation</title>
    <link rel="stylesheet" href="../../_static/haiku-site.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.6.19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js"></script>
    <script type="text/javascript" src="../../_static/theme_extras.js"></script>
    <link rel="top" title="Refl1D v0.6.19 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="../../_static/logo.png" alt="Logo"/><h1 class="heading"><a href="../../index.html">
          <span>Refl1D v0.6.19 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.instrument</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for refl1d.instrument</h1><div class="highlight"><pre>
<span class="c"># This program is in the public domain</span>
<span class="c"># Author: Paul Kienzle</span>
<span class="s">r&quot;&quot;&quot;</span>
<span class="s">Reflectometry instrument definitions.</span>

<span class="s">An instrument definition contains all the information necessary to compute</span>
<span class="s">the resolution for a measurement.  See :mod:`resolution` for details.</span>

<span class="s">This module is intended to help define new instrument loaders</span>

<span class="s">Scanning Reflectometers</span>
<span class="s">=======================</span>

<span class="s">:mod:`refl1d.instrument` (this module) defines two instrument types:</span>
<span class="s">:class:`Monochromatic` and :class:`Pulsed`. These represent</span>
<span class="s">generic scanning and time of flight instruments, respectively.</span>

<span class="s">To perform a simulation or load a data set, a measurement geometry must</span>
<span class="s">be defined.  In the following example, we set up the geometry for a</span>
<span class="s">pretend instrument SP:2. The complete geometry needs to include information</span>
<span class="s">to calculate wavelength resolution (wavelength and wavelength dispersion)</span>
<span class="s">as well as angular resolution (slit distances and openings, and perhaps</span>
<span class="s">sample size and sample warp).  In this case, we are using a scanning</span>
<span class="s">monochromatic instrument with slits of 0.1 mm below 0.5\ |deg| and</span>
<span class="s">opening slits  above 0.5\ |deg| starting at 0.2 mm.  The monochromatic</span>
<span class="s">instrument assumes a fixed $\Delta \theta / \theta$ while opening.</span>

<span class="s">    &gt;&gt;&gt; from refl1d.names import *</span>
<span class="s">    &gt;&gt;&gt; geometry = Monochromatic(instrument=&quot;SP:2&quot;, radiation=&quot;neutron&quot;,</span>
<span class="s">    ...    wavelength=5.0042, dLoL=0.009, d_s1=230+1856, d_s2=230,</span>
<span class="s">    ...    Tlo=0.5, slits_at_Tlo=0.2, slits_below=0.1)</span>

<span class="s">This instrument can be used to  a data file, or generate a</span>
<span class="s">measurement probe for use in modeling or to read in a previously</span>
<span class="s">measured data set or generate a probe for simulation:</span>

<span class="s">    &gt;&gt;&gt; from numpy import linspace, loadtxt</span>
<span class="s">    &gt;&gt;&gt; datafile = sample_data(&#39;10ndt001.refl&#39;)</span>
<span class="s">    &gt;&gt;&gt; Q,R,dR = loadtxt(datafile).T</span>
<span class="s">    &gt;&gt;&gt; probe = geometry.probe(Q=Q, data=(R,dR))</span>
<span class="s">    &gt;&gt;&gt; simulation = geometry.probe(T=linspace(0,5,51))</span>

<span class="s">All instrument parameters can be specified when constructing the probe,</span>
<span class="s">replacing the defaults that are associated with the instrument.  For</span>
<span class="s">example, to include sample broadening effects in the resolution:</span>

<span class="s">    &gt;&gt;&gt; probe2 = geometry.probe(Q=Q, data=(R,dR), sample_broadening=0.1)</span>

<span class="s">For magnetic systems a polarized beam probe is needed::</span>

<span class="s">    &gt;&gt;&gt; magnetic_probe = geometry.magnetic_probe(T=numpy.linspace(0,5,100))</span>

<span class="s">The string representation of the geometry prints a multi-line</span>
<span class="s">description of the default instrument configuration:</span>

<span class="s">    &gt;&gt;&gt; print geometry</span>
<span class="s">    == Instrument SP:2 ==</span>
<span class="s">    radiation = neutron at 5.0042 Angstrom with 0.9</span><span class="si">% r</span><span class="s">esolution</span>
<span class="s">    slit distances = 2086 mm and 230 mm</span>
<span class="s">    fixed region below 0.5 and above 90 degrees</span>
<span class="s">    slit openings at Tlo are 0.2 mm</span>
<span class="s">    sample width = 1e+10 mm</span>
<span class="s">    sample broadening = 0 degrees</span>

<span class="s">Predefined Instruments</span>
<span class="s">======================</span>

<span class="s">Specific instruments can be defined for each facility.  This saves the users</span>
<span class="s">having to remember details of the instrument geometry.</span>

<span class="s">For example, the above SP:2 instrument could be defined as follows:</span>

<span class="s">    &gt;&gt;&gt; class SP2(Monochromatic):</span>
<span class="s">    ...    instrument = &quot;SP:2&quot;</span>
<span class="s">    ...    radiation = &quot;neutron&quot;</span>
<span class="s">    ...    wavelength = 5.0042   # Angstroms</span>
<span class="s">    ...    dLoL = 0.009          # FWHM</span>
<span class="s">    ...    d_s1 = 230.0 + 1856.0 # mm</span>
<span class="s">    ...    d_s2 = 230.0          # mm</span>
<span class="s">    ...    def load(self, filename, **kw):</span>
<span class="s">    ...        Q,R,dR = loadtxt(datafile).T</span>
<span class="s">    ...        probe = self.probe(Q=Q, data=(R,dR), **kw)</span>
<span class="s">    ...        return probe</span>

<span class="s">This definition can then be used to define the measurement geometry.  We</span>
<span class="s">have added a load method which knows about the facility file format (in</span>
<span class="s">this case, three column ASCII data Q, R, dR) so that we can load a datafile</span>
<span class="s">in a couple of lines of code:</span>

<span class="s">    &gt;&gt;&gt; geometry = SP2(Tlo=0.5, slits_at_Tlo=0.2, slits_below=0.1)</span>
<span class="s">    &gt;&gt;&gt; probe3 = geometry.load(datafile)</span>

<span class="s">The defaults() method prints the static components of the geometry:</span>

<span class="s">    &gt;&gt;&gt; print SP2.defaults()</span>
<span class="s">    == Instrument class SP:2 ==</span>
<span class="s">    radiation = neutron at 5.0042 Angstrom with 0.9</span><span class="si">% r</span><span class="s">esolution</span>
<span class="s">    slit distances = 2086 mm and 230 mm</span>

<span class="s">GUI Usage</span>
<span class="s">=========</span>

<span class="s">Graphical user interfaces follow different usage patterns from scripts.</span>
<span class="s">Here the emphasis will be on selecting a data set to process, displaying</span>
<span class="s">its default metadata and allowing the user to override it.</span>

<span class="s">File loading should follow the pattern established in reflectometry</span>
<span class="s">reduction, with an extension registry and a fallback scheme whereby</span>
<span class="s">files can be checked in a predefined order.  If the file cannot be</span>
<span class="s">loaded, then the next loader is tried.  This should be extended with</span>
<span class="s">the concept of a magic signature such as those used by graphics and</span>
<span class="s">sound file applications: read the first block and run it through</span>
<span class="s">the signature check before trying to load it.  For unrecognized</span>
<span class="s">extensions, all loaders can be tried.</span>

<span class="s">The file loader should return an instrument instance with metadata</span>
<span class="s">initialized from the file header.  This metadata can be displayed</span>
<span class="s">to the user along with a plot of the data and the resolution.  When</span>
<span class="s">metadata values are changed, the resolution can be recomputed and the</span>
<span class="s">display updated.  When the data set is accepted, the final resolution</span>
<span class="s">calculation can be performed.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="c"># TODO: the resolution calculator should not be responsible for loading</span>
<span class="c"># the data; maybe do it as a mixin?</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="c">#from numpy import pi, inf, sqrt, log, degrees, radians, cos, sin, tan</span>
<span class="kn">from</span> <span class="nn">resolution</span> <span class="kn">import</span> <span class="n">TL2Q</span><span class="p">,</span> <span class="n">QL2T</span><span class="p">,</span> <span class="n">dTdL2dQ</span><span class="p">,</span> <span class="n">dQdT2dLoL</span><span class="p">,</span> <span class="n">FWHM2sigma</span><span class="p">,</span> <span class="n">sigma2FWHM</span>
<span class="kn">from</span> <span class="nn">resolution</span> <span class="kn">import</span> <span class="n">bins</span><span class="p">,</span> <span class="n">binwidths</span><span class="p">,</span> <span class="n">binedges</span>
<span class="kn">from</span> <span class="nn">resolution</span> <span class="kn">import</span> <span class="n">slit_widths</span><span class="p">,</span> <span class="n">divergence</span>
<span class="kn">from</span> <span class="nn">probe</span> <span class="kn">import</span> <span class="n">make_probe</span><span class="p">,</span> <span class="n">PolarizedNeutronProbe</span>


<div class="viewcode-block" id="Monochromatic"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic">[docs]</a><span class="k">class</span> <span class="nc">Monochromatic</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instrument representation for scanning reflectometers.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *instrument* : string</span>
<span class="sd">            name of the instrument</span>
<span class="sd">        *radiation* : string | xray or neutron</span>
<span class="sd">            source radiation type</span>
<span class="sd">        *d_s1*, *d_s2* : float | mm</span>
<span class="sd">            distance from sample to pre-sample slits 1 and 2; post-sample</span>
<span class="sd">            slits are ignored</span>
<span class="sd">        *wavelength* : float | |Ang|</span>
<span class="sd">            wavelength of the instrument</span>
<span class="sd">        *dLoL* : float</span>
<span class="sd">            constant relative wavelength dispersion; wavelength range and</span>
<span class="sd">            dispersion together determine the bins</span>
<span class="sd">        *slits* : float OR (float,float) | mm</span>
<span class="sd">            fixed slits</span>
<span class="sd">        *slits_at_Tlo* : float OR (float,float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings at Tlo; this can be a scalar if both</span>
<span class="sd">            slits are open by the same amount, otherwise it is a pair (s1,s2).</span>
<span class="sd">        *slits_at_Qlo* : float OR (float,float) | mm</span>
<span class="sd">            equivalent to slits_at_Tlo, for instruments that are controlled by</span>
<span class="sd">            Q rather than theta</span>
<span class="sd">        *Tlo*, *Thi* : float | |deg|</span>
<span class="sd">            range of opening slits, or inf if slits are fixed.</span>
<span class="sd">        *Qlo*, *Qhi* : float | |1/Ang|</span>
<span class="sd">            range of opening slits when instrument is controlled by Q.</span>
<span class="sd">        *slits_below*, *slits_above* : float OR (float,float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings below Tlo and above Thi; again, these</span>
<span class="sd">            can be scalar if slit 1 and slit 2 are the same, otherwise they</span>
<span class="sd">            are each a pair (s1,s2).  Below and above default to the values of</span>
<span class="sd">            the slits at Tlo and Thi respectively.</span>
<span class="sd">        *sample_width* : float | mm</span>
<span class="sd">            width of sample; at low angle with tiny samples, stray neutrons</span>
<span class="sd">            miss the sample and are not reflected onto the detector, so the</span>
<span class="sd">            sample itself acts as a slit, therefore the width of the sample</span>
<span class="sd">            may be needed to compute the resolution correctly</span>
<span class="sd">        *sample_broadening* : float | |deg| FWHM</span>
<span class="sd">            amount of angular divergence (+) or focusing (-) introduced by</span>
<span class="sd">            the sample; this is caused by sample warp, and may be read off</span>
<span class="sd">            of the rocking curve by subtracting (s1+s2)/2/(d_s1-d_s2) from</span>
<span class="sd">            the FWHM width of the rocking curve</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">instrument</span> <span class="o">=</span> <span class="s">&quot;monochromatic&quot;</span>
    <span class="n">radiation</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span>
    <span class="c"># Required attributes</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">dLoL</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">d_s1</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">d_s2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c"># Optional attributes</span>
    <span class="n">Tlo</span><span class="o">=</span> <span class="mf">90</span>  <span class="c"># Use 90 for fixed slits; this is effectively inf</span>
    <span class="n">Thi</span><span class="o">=</span> <span class="mf">90</span>
    <span class="n">fixed_slits</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c"># Slit openings at Tlo, and default for slits_below</span>
    <span class="n">slits_below</span> <span class="o">=</span> <span class="bp">None</span>     <span class="c"># Slit openings below Tlo, or fixed slits if Tlo=90</span>
    <span class="n">slits_above</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">sample_width</span> <span class="o">=</span> <span class="mf">1e10</span>    <span class="c"># Large but finite value</span>
    <span class="n">sample_broadening</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span><span class="o">%</span><span class="n">k</span><span class="p">)</span>

<div class="viewcode-block" id="Monochromatic.probe"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic.probe">[docs]</a>    <span class="k">def</span> <span class="nf">probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a probe for use in simulation.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *Q* : [float] | |Ang|</span>
<span class="sd">                Q values to be measured.</span>
<span class="sd">            *T* : [float] | |deg|</span>
<span class="sd">                Angles to be measured.</span>

<span class="sd">        Additional keyword parameters</span>

<span class="sd">        :Returns:</span>
<span class="sd">            *probe* : Probe</span>
<span class="sd">                Measurement probe with complete resolution information.  The</span>
<span class="sd">                probe will not have any data.</span>

<span class="sd">        If both *Q* and *T* are specified then *Q* takes precedents.</span>

<span class="sd">        You can override instrument parameters using key=value.  In</span>
<span class="sd">        particular, settings for *slits_at_Tlo*, *Tlo*, *Thi*,</span>
<span class="sd">        *slits_below*, and *slits_above* are used to define the</span>
<span class="sd">        angular divergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">T</span><span class="p">,</span><span class="n">dT</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">dL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span><span class="n">dT</span><span class="o">=</span><span class="n">dT</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">)</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;radiation&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_probe</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Monochromatic.magnetic_probe"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic.magnetic_probe">[docs]</a>    <span class="k">def</span> <span class="nf">magnetic_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="mf">270</span><span class="p">,</span> <span class="n">shared_beam</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a polarized measurement probe.</span>

<span class="sd">        Returns a probe with Q, angle, wavelength and the associated</span>
<span class="sd">        uncertainties, but not any data.</span>

<span class="sd">        Guide field angle *Aguide* can be specified, as well as keyword</span>
<span class="sd">        arguments for the geometry of the probe cross sections such as</span>
<span class="sd">        *slits_at_Tlo*, *Tlo*, *Thi*, *slits_below*, and *slits_above*</span>
<span class="sd">        to define the angular divergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">4</span><span class="p">)]</span>
        <span class="n">probe</span> <span class="o">=</span> <span class="n">PolarizedNeutronProbe</span><span class="p">(</span><span class="n">probes</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="n">Aguide</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shared_beam</span><span class="p">:</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">shared_beam</span><span class="p">()</span>  <span class="c"># Share the beam parameters by default</span>
        <span class="k">return</span> <span class="n">probe</span>
</div>
<div class="viewcode-block" id="Monochromatic.resolution"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic.resolution">[docs]</a>    <span class="k">def</span> <span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate resolution at each angle.</span>

<span class="sd">        :Return:</span>
<span class="sd">            *T*, *dT* : [float] | |deg|</span>
<span class="sd">                Angles and angular divergence.</span>
<span class="sd">            *L*, *dL* : [float] | |Ang|</span>
<span class="sd">                Wavelengths and wavelength dispersion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;T&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;resolution requires slits and either T or Q&quot;</span><span class="p">)</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,</span><span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;wavelength&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">))</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dLoL&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Need wavelength L to compute resolution&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dLoL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Need wavelength dispersion dLoL to compute resolution&quot;</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&#39;slits&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s">&#39;slits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_slits</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_dT</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">T</span><span class="p">,</span><span class="n">dT</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">dLoL</span><span class="o">*</span><span class="n">L</span>
</div>
<div class="viewcode-block" id="Monochromatic.calc_slits"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic.calc_slits">[docs]</a>    <span class="k">def</span> <span class="nf">calc_slits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines slit openings from measurement pattern.</span>

<span class="sd">        If slits are fixed simply return the same slits for every angle,</span>
<span class="sd">        otherwise use an opening range [Tlo,Thi] and the value of the</span>
<span class="sd">        slits at the start of the opening to define the slits.  Slits</span>
<span class="sd">        below Tlo and above Thi can be specified separately.</span>

<span class="sd">        *T* OR *Q*       incident angle or Q</span>
<span class="sd">        *Tlo*, *Thi*     angle range over which slits are opening</span>
<span class="sd">        *slits_at_Tlo*   openings at the start of the range, or fixed opening</span>
<span class="sd">        *slits_below*, *slits_above*   openings below and above the range</span>

<span class="sd">        Use fixed_slits is available, otherwise use opening slits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;T&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;calc_slits requires angle T=... or Q=...&quot;</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Tlo&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Tlo</span><span class="p">)</span>
        <span class="n">Thi</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Thi&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Thi</span><span class="p">)</span>
        <span class="n">fixed_slits</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;fixed_slits&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_slits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed_slits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">slits_below</span> <span class="o">=</span> <span class="n">slits_above</span> <span class="o">=</span> <span class="n">fixed_slits</span>
            <span class="n">Tlo</span> <span class="o">=</span> <span class="mf">90</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;slits_at_Tlo&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_at_Tlo</span><span class="p">)</span>
            <span class="n">slits_below</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;slits_below&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_below</span><span class="p">)</span>
            <span class="n">slits_above</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;slits_above&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_above</span><span class="p">)</span>

        <span class="c"># Otherwise we are using opening slits</span>
        <span class="k">if</span> <span class="n">Tlo</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">slits_at_Tlo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Resolution calculation requires Tlo and slits_at_Tlo&quot;</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">slit_widths</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="n">slits_at_Tlo</span><span class="p">,</span>
                            <span class="n">Tlo</span><span class="o">=</span><span class="n">Tlo</span><span class="p">,</span> <span class="n">Thi</span><span class="o">=</span><span class="n">Thi</span><span class="p">,</span>
                            <span class="n">slits_below</span><span class="o">=</span><span class="n">slits_below</span><span class="p">,</span>
                            <span class="n">slits_above</span><span class="o">=</span><span class="n">slits_above</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">slits</span>
</div>
<div class="viewcode-block" id="Monochromatic.calc_dT"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic.calc_dT">[docs]</a>    <span class="k">def</span> <span class="nf">calc_dT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the angular divergence for given slits and angles</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *T* OR *Q* : [float] | |deg| OR |1/Ang|</span>
<span class="sd">                measurement angles</span>
<span class="sd">            *slits* : float OR (float,float) | mm</span>
<span class="sd">                total slit opening from edge to edge, not beam center to edge</span>
<span class="sd">            *d_s1*, *d_s2* : float | mm</span>
<span class="sd">                distance from sample to slit 1 and slit 2</span>
<span class="sd">            *sample_width* : float | mm</span>
<span class="sd">                size of sample</span>
<span class="sd">            *sample_broadening* : float | |deg| FWHM</span>
<span class="sd">                resolution changes from sample warp</span>

<span class="sd">        :Returns:</span>
<span class="sd">            *dT* : [float] | |deg| FWHM</span>
<span class="sd">                angular divergence</span>

<span class="sd">        *sample_broadening* can be estimated from W, the full width at half</span>
<span class="sd">        maximum of a rocking curve measured in degrees:</span>

<span class="sd">            sample_broadening = W - degrees( 0.5*(s1+s2) / (d1-d2))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;T&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span> <span class="ow">or</span> <span class="s">&#39;slits&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;calc_dT requires slits and either T or Q&quot;</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;slits&#39;</span><span class="p">]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">d_s1</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;d_s1&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">)</span>
        <span class="n">d_s2</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;d_s2&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d_s1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">d_s2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Need slit distances d_s1, d_s2 to compute resolution&quot;</span><span class="p">)</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;sample_width&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">)</span>
        <span class="n">sample_broadening</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;sample_broadening&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="n">divergence</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="n">slits</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">d_s1</span><span class="p">,</span><span class="n">d_s2</span><span class="p">),</span>
                        <span class="n">sample_width</span><span class="o">=</span><span class="n">sample_width</span><span class="p">,</span>
                        <span class="n">sample_broadening</span><span class="o">=</span><span class="n">sample_broadening</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dT</span>
</div>
    <span class="k">def</span> <span class="nf">_translate_Q_to_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewrite keyword arguments with Q values translated to theta values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Grab wavelength first so we can translate Qlo/Qhi to Tlo/Thi no</span>
        <span class="c"># matter what order the keywords appear.</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;wavelength&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;Q&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;Q&quot;</span><span class="p">),</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;Qlo&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s">&quot;Tlo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;Qlo&quot;</span><span class="p">),</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;Qhi&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s">&quot;Thi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;Qhi&quot;</span><span class="p">),</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;slits_at_Qlo&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s">&quot;slits_at_Tlo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;slits_at_Qlo&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">== Instrument </span><span class="si">%(name)s</span><span class="s"> ==</span>
<span class="s">radiation = </span><span class="si">%(radiation)s</span><span class="s"> at </span><span class="si">%(L)g</span><span class="s"> Angstrom with </span><span class="si">%(dLpercent)g%%</span><span class="s"> resolution</span>
<span class="s">slit distances = %(d_s1)g mm and %(d_s2)g mm</span>
<span class="s">fixed region below </span><span class="si">%(Tlo)g</span><span class="s"> and above </span><span class="si">%(Thi)g</span><span class="s"> degrees</span>
<span class="s">slit openings at Tlo are %(slits_at_Tlo)s mm</span>
<span class="s">sample width = %(sample_width)g mm</span>
<span class="s">sample broadening = %(sample_broadening)g degrees</span><span class="se">\</span>
<span class="s">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">dLpercent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="o">*</span><span class="mf">100</span><span class="p">,</span>
           <span class="n">d_s1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">,</span>
           <span class="n">sample_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">,</span>
           <span class="n">sample_broadening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">,</span>
           <span class="n">Tlo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Tlo</span><span class="p">,</span> <span class="n">Thi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Thi</span><span class="p">,</span>
           <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_at_Tlo</span><span class="p">),</span> <span class="n">radiation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
           <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Monochromatic.defaults"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Monochromatic.defaults">[docs]</a>    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return default instrument properties as a printable string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">== Instrument class </span><span class="si">%(name)s</span><span class="s"> ==</span>
<span class="s">radiation = </span><span class="si">%(radiation)s</span><span class="s"> at </span><span class="si">%(L)s</span><span class="s"> Angstrom with </span><span class="si">%(dL)s</span><span class="s"> resolution</span>
<span class="s">slit distances = %(d_s1)s mm and %(d_s2)s mm&quot;&quot;&quot;</span>
        <span class="n">L</span><span class="p">,</span><span class="n">d_s1</span><span class="p">,</span><span class="n">d_s2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%g</span><span class="s">&quot;</span><span class="o">%</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&#39;unknown&#39;</span>
                       <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">d_s2</span><span class="p">]</span>
        <span class="n">dL</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%g%%</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">dLoL</span><span class="o">*</span><span class="mf">100</span><span class="p">)</span> <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">dLoL</span> <span class="k">else</span> <span class="s">&#39;unknown&#39;</span>
        <span class="k">return</span> <span class="n">msg</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="n">radiation</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
                          <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">,</span> <span class="n">d_s1</span><span class="o">=</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="o">=</span><span class="n">d_s2</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="Pulsed"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed">[docs]</a><span class="k">class</span> <span class="nc">Pulsed</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instrument representation for pulsed reflectometers.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *instrument* : string</span>
<span class="sd">            name of the instrument</span>
<span class="sd">        *radiation* : string | xray, neutron</span>
<span class="sd">            source radiation type</span>
<span class="sd">        *TOF_range* : (float, float)</span>
<span class="sd">            usabe range of times for TOF data</span>
<span class="sd">        *T* : float | |deg|</span>
<span class="sd">            sample angle</span>
<span class="sd">        *d_s1*, *d_s2* : float | mm</span>
<span class="sd">            distance from sample to pre-sample slits 1 and 2; post-sample</span>
<span class="sd">            slits are ignored</span>
<span class="sd">        *wavelength* : (float,float) | |Ang|</span>
<span class="sd">            wavelength range for the measurement</span>
<span class="sd">        *dLoL* : float</span>
<span class="sd">            constant relative wavelength dispersion; wavelength range and</span>
<span class="sd">            dispersion together determine the bins</span>
<span class="sd">        *slits* : float OR (float,float) | mm</span>
<span class="sd">            fixed slits</span>
<span class="sd">        *slits_at_Tlo* : float OR (float,float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings at Tlo; this can be a scalar if both</span>
<span class="sd">            slits are open by the same amount, otherwise it is a pair (s1,s2).</span>
<span class="sd">        *Tlo*, *Thi* : float | |deg|</span>
<span class="sd">            range of opening slits, or inf if slits are fixed.</span>
<span class="sd">        *slits_below*, *slits_above* : float OR (float,float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings below Tlo and above Thi; again, these</span>
<span class="sd">            can be scalar if slit 1 and slit 2 are the same, otherwise they</span>
<span class="sd">            are each a pair (s1,s2).  Below and above default to the values of</span>
<span class="sd">            the slits at Tlo and Thi respectively.</span>
<span class="sd">        *sample_width* : float | mm</span>
<span class="sd">            width of sample; at low angle with tiny samples, stray neutrons</span>
<span class="sd">            miss the sample and are not reflected onto the detector, so the</span>
<span class="sd">            sample itself acts as a slit, therefore the width of the sample</span>
<span class="sd">            may be needed to compute the resolution correctly</span>
<span class="sd">        *sample_broadening* : float | |deg| FWHM</span>
<span class="sd">            amount of angular divergence (+) or focusing (-) introduced by</span>
<span class="sd">            the sample; this is caused by sample warp, and may be read off</span>
<span class="sd">            of the rocking curve by subtracting 0.5*(s1+s2)/(d_s1-d_s2) from</span>
<span class="sd">            the FWHM width of the rocking curve</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">instrument</span> <span class="o">=</span> <span class="s">&quot;pulsed&quot;</span>
    <span class="n">radiation</span> <span class="o">=</span> <span class="s">&quot;neutron&quot;</span> <span class="c"># unless someone knows how to do TOF Xray...</span>
    <span class="c"># Required attributes</span>
    <span class="n">d_s1</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">d_s2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">slits</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">dLoL</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># usually 0.02 for 2% FWHM</span>
    <span class="c"># Optional attributes</span>
    <span class="n">TOF_range</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">Tlo</span><span class="o">=</span> <span class="mf">90</span>  <span class="c"># Use 90 for fixed slits; this is effectively inf</span>
    <span class="n">Thi</span><span class="o">=</span> <span class="mf">90</span>
    <span class="n">fixed_slits</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c"># Slit openings at Tlo, and default for slits_below</span>
    <span class="n">slits_below</span> <span class="o">=</span> <span class="bp">None</span>     <span class="c"># Slit openings below Tlo, or fixed slits if Tlo=90</span>
    <span class="n">slits_above</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">sample_width</span> <span class="o">=</span> <span class="mf">1e10</span>    <span class="c"># Large but finite value</span>
    <span class="n">sample_broadening</span> <span class="o">=</span> <span class="mf">0</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span><span class="o">%</span><span class="n">k</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="Pulsed.probe"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.probe">[docs]</a>    <span class="k">def</span> <span class="nf">probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a measurement probe.</span>

<span class="sd">        Returns a probe with Q, angle, wavelength and the associated</span>
<span class="sd">        uncertainties, but not any data.</span>

<span class="sd">        You can override instrument parameters using key=value.</span>
<span class="sd">        In particular, slit settings *slits* and *T* define</span>
<span class="sd">        the angular divergence and *dLoL* defines the wavelength</span>
<span class="sd">        resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">low</span><span class="p">,</span><span class="n">high</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;wavelength&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dLoL&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">bins</span><span class="p">(</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">dLoL</span><span class="p">)</span>
        <span class="n">dL</span> <span class="o">=</span> <span class="n">binwidths</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">T</span><span class="p">,</span><span class="n">dT</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">dL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_probe</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span><span class="n">dT</span><span class="o">=</span><span class="n">dT</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">,</span>
                          <span class="n">radiation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Pulsed.magnetic_probe"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.magnetic_probe">[docs]</a>    <span class="k">def</span> <span class="nf">magnetic_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="mf">270</span><span class="p">,</span> <span class="n">shared_beam</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a polarized measurement probe.</span>

<span class="sd">        Returns a probe with Q, angle, wavelength and the associated</span>
<span class="sd">        uncertainties, but not any data.</span>

<span class="sd">        Guide field angle *Aguide* can be specified, as well as keyword</span>
<span class="sd">        arguments for the geometry of the probe cross sections such as</span>
<span class="sd">        slit settings *slits* and *T* to define the angular divergence</span>
<span class="sd">        and *dLoL* to define the wavelength resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">4</span><span class="p">)]</span>
        <span class="n">probe</span> <span class="o">=</span> <span class="n">PolarizedNeutronProbe</span><span class="p">(</span><span class="n">probes</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="n">Aguide</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shared_beam</span><span class="p">:</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">shared_beam</span><span class="p">()</span>  <span class="c"># Share the beam parameters by default</span>
        <span class="k">return</span> <span class="n">probe</span>
</div>
<div class="viewcode-block" id="Pulsed.simulate"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">uncertainty</span><span class="o">=</span><span class="mf">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a run with a particular sample.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *sample* : Stack</span>
<span class="sd">                Reflectometry model</span>
<span class="sd">            *T* : [float] | |deg|</span>
<span class="sd">                List of angles to be measured, such as [0.15,0.4,1,2].</span>
<span class="sd">            *slits* : [float] or [(float,float)] | mm</span>
<span class="sd">                Slit settings for each angle.</span>
<span class="sd">            *uncertainty* = 1 : float or [float] | %</span>
<span class="sd">                Incident intensity is set so that the median dR/R is equal</span>
<span class="sd">                to *uncertainty*, where R is the idealized reflectivity</span>
<span class="sd">                of the sample.</span>
<span class="sd">            *dLoL* = 0.02: float</span>
<span class="sd">                Wavelength resolution</span>
<span class="sd">            *normalize* = True : boolean</span>
<span class="sd">                Whether to normalize the intensities</span>
<span class="sd">            *theta_offset* = 0 : float | |deg|</span>
<span class="sd">                Sample alignment error</span>
<span class="sd">            *background* = 0 : float</span>
<span class="sd">                Background counts per incident neutron (background is</span>
<span class="sd">                assumed to be independent of measurement geometry).</span>
<span class="sd">            *back_reflectivity* = False : boolean</span>
<span class="sd">                Whether beam travels through incident medium</span>
<span class="sd">                or through substrate.</span>
<span class="sd">            *back_absorption* = 1 : float</span>
<span class="sd">                Absorption factor for beam traveling through substrate.</span>
<span class="sd">                Only needed for back reflectivity measurements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">poisson</span> <span class="k">as</span> <span class="n">pois</span>
        <span class="kn">from</span> <span class="nn">.rebin</span> <span class="kn">import</span> <span class="n">rebin</span>
        <span class="kn">from</span> <span class="nn">.experiment</span> <span class="kn">import</span> <span class="n">Experiment</span>
        <span class="kn">from</span> <span class="nn">.probe</span> <span class="kn">import</span> <span class="n">ProbeSet</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;slits&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slits</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Need slit openings for simulation&#39;</span><span class="p">)</span>

        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;dLoL&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="p">)</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;normalize&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">theta_offset</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;theta_offset&#39;</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;background&#39;</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
        <span class="n">back_reflectivity</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;back_reflectivity&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">back_absorption</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;back_absorption&#39;</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
        <span class="n">uncertainty</span> <span class="o">*=</span> <span class="mf">0.01</span>

        <span class="c"># Compute reflectivity with resolution and added noise</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">Ti</span><span class="p">,</span><span class="n">Si</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">slits</span><span class="p">):</span>
            <span class="n">probe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">Ti</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="n">Si</span><span class="p">,</span> <span class="n">dLoL</span><span class="o">=</span><span class="n">dLoL</span><span class="p">)</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">back_reflectivity</span> <span class="o">=</span> <span class="n">back_reflectivity</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">theta_offset</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">theta_offset</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">back_absorption</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">back_absorption</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">Experiment</span><span class="p">(</span><span class="n">probe</span><span class="o">=</span><span class="n">probe</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="n">sample</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Rth</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">reflectivity</span><span class="p">()</span>
            <span class="c"># Note: probe.L is reversed because L is sorted by increasing</span>
            <span class="c"># Q in probe.</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">rebin</span><span class="p">(</span><span class="n">binedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feather</span><span class="p">[</span><span class="mf">0</span><span class="p">]),</span><span class="bp">self</span><span class="o">.</span><span class="n">feather</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span>
                      <span class="n">binedges</span><span class="p">(</span><span class="n">probe</span><span class="o">.</span><span class="n">L</span><span class="p">[::</span><span class="o">-</span><span class="mf">1</span><span class="p">]))[::</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
            <span class="n">Ci</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">uncertainty</span><span class="o">**</span><span class="mf">2</span> <span class="o">*</span> <span class="n">I</span> <span class="o">*</span> <span class="n">Rth</span><span class="p">))</span>
            <span class="n">Igoal</span> <span class="o">=</span> <span class="n">Ci</span><span class="o">*</span><span class="n">I</span>
            <span class="n">Ibeam</span> <span class="o">=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span>

            <span class="n">Irefl</span> <span class="o">=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span><span class="o">*</span><span class="n">Rth</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span>
            <span class="k">if</span> <span class="n">background</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">:</span>
                <span class="n">Irefl</span> <span class="o">+=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span><span class="o">*</span><span class="n">background</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span>
                <span class="n">Iback</span>  <span class="o">=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span><span class="o">*</span><span class="n">background</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Iback</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="c"># Set intensity/background _after_ calculating the theory function</span>
            <span class="c"># since we don&#39;t want the theory function altered by them.</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">background</span>
            <span class="c"># Correct for the feather.  This has to be done otherwise we</span>
            <span class="c"># won&#39;t see the correct reflectivity.  Even if corrected for</span>
            <span class="c"># the feather, though, we haven&#39;t necessarily corrected for</span>
            <span class="c"># the overall number of counts in the measurement.</span>
            <span class="c"># Z = X/Y</span>
            <span class="c"># var Z = ( (var X / X)**2 + (var Y / Y)**2 ) * Z**2</span>
            <span class="c">#       = (1/X + 1/Y) * (X/Y)**2</span>
            <span class="c">#       = (Y + X) * X/Y**3</span>
            <span class="c">#    dZ = sqrt( (Y+X)*X/Y**3) = sqrt((Y+X)*(X/Y))/Y</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">Irefl</span><span class="o">-</span><span class="n">Iback</span><span class="p">)</span><span class="o">/</span><span class="n">Ibeam</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Irefl</span> <span class="o">+</span> <span class="n">Iback</span> <span class="o">+</span> <span class="n">Ibeam</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Irefl</span><span class="o">/</span><span class="n">Ibeam</span><span class="p">))</span><span class="o">/</span><span class="n">Ibeam</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dR</span><span class="o">==</span><span class="mf">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">R</span><span class="o">&lt;=</span><span class="mf">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">print</span> <span class="s">&quot;Ibeam&quot;</span><span class="p">,</span><span class="n">Ibeam</span>
                <span class="k">print</span> <span class="s">&quot;Irefl&quot;</span><span class="p">,</span><span class="n">Irefl</span>
                <span class="k">print</span> <span class="s">&quot;Iback&quot;</span><span class="p">,</span><span class="n">Iback</span>
                <span class="k">print</span> <span class="s">&quot;R&quot;</span><span class="p">,</span><span class="n">R</span>
                <span class="k">print</span> <span class="s">&quot;dR&quot;</span><span class="p">,</span><span class="n">dR</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Should not be able to get here!!&quot;</span><span class="p">)</span>
            <span class="c">#dR[Irefl==0] == 1./Ibeam[Irefl==0]</span>
            <span class="c">#print &quot;median&quot;,numpy.median(dR/R)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="c">#Ci = 1./max(R)</span>
                <span class="n">R</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">Ci</span><span class="p">,</span> <span class="n">dR</span><span class="o">*</span><span class="n">Ci</span>
                <span class="n">probe</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">value</span> <span class="o">*=</span> <span class="n">Ci</span>
                <span class="n">probe</span><span class="o">.</span><span class="n">intensity</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Ci</span>

            <span class="n">probe</span><span class="o">.</span><span class="n">Ro</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">R</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span>
            <span class="n">probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probe</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Experiment</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="n">sample</span><span class="p">,</span> <span class="n">probe</span><span class="o">=</span><span class="n">ProbeSet</span><span class="p">(</span><span class="n">probes</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Pulsed.resolution"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.resolution">[docs]</a>    <span class="k">def</span> <span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the resolution of the measurement.  Needs *T*, *L*, *dL*</span>
<span class="sd">        specified as keywords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;slits&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s">&#39;slits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_slits</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_dT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="c"># Compute the FWHM angular divergence in radians</span>
        <span class="c"># Return the resolution</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">,</span><span class="n">dT</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">dL</span>
</div>
<div class="viewcode-block" id="Pulsed.calc_slits"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.calc_slits">[docs]</a>    <span class="k">def</span> <span class="nf">calc_slits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines slit openings from measurement pattern.</span>

<span class="sd">        If slits are fixed simply return the same slits for every angle,</span>
<span class="sd">        otherwise use an opening range [Tlo,Thi] and the value of the</span>
<span class="sd">        slits at the start of the opening to define the slits.  Slits</span>
<span class="sd">        below Tlo and above Thi can be specified separately.</span>

<span class="sd">        *T*              incident angle</span>
<span class="sd">        *Tlo*, *Thi*     angle range over which slits are opening</span>
<span class="sd">        *slits_at_Tlo*   openings at the start of the range, or fixed opening</span>
<span class="sd">        *slits_below*, *slits_above*   openings below and above the range</span>

<span class="sd">        Use fixed_slits is available, otherwise use opening slits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;T&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;calc_slits requires angle T=...&quot;</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Tlo&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Tlo</span><span class="p">)</span>
        <span class="n">Thi</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Thi&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Thi</span><span class="p">)</span>
        <span class="n">fixed_slits</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;fixed_slits&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_slits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed_slits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">slits_below</span> <span class="o">=</span> <span class="n">slits_above</span> <span class="o">=</span> <span class="n">fixed_slits</span>
            <span class="n">Tlo</span> <span class="o">=</span> <span class="mf">90</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;slits_at_Tlo&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_at_Tlo</span><span class="p">)</span>
            <span class="n">slits_below</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;slits_below&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_below</span><span class="p">)</span>
            <span class="n">slits_above</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;slits_above&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_above</span><span class="p">)</span>

        <span class="c"># Otherwise we are using opening slits</span>
        <span class="k">if</span> <span class="n">Tlo</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">slits_at_Tlo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Resolution calculation requires Tlo and slits_at_Tlo&quot;</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">slit_widths</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="n">slits_at_Tlo</span><span class="p">,</span>
                            <span class="n">Tlo</span><span class="o">=</span><span class="n">Tlo</span><span class="p">,</span> <span class="n">Thi</span><span class="o">=</span><span class="n">Thi</span><span class="p">,</span>
                            <span class="n">slits_below</span><span class="o">=</span><span class="n">slits_below</span><span class="p">,</span>
                            <span class="n">slits_above</span><span class="o">=</span><span class="n">slits_above</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">slits</span>
</div>
<div class="viewcode-block" id="Pulsed.calc_dT"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.calc_dT">[docs]</a>    <span class="k">def</span> <span class="nf">calc_dT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">d_s1</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;d_s1&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">)</span>
        <span class="n">d_s2</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;d_s2&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">)</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;sample_width&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">)</span>
        <span class="n">sample_broadening</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;sample_broadening&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="n">divergence</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="n">slits</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">d_s1</span><span class="p">,</span><span class="n">d_s2</span><span class="p">),</span>
                        <span class="n">sample_width</span><span class="o">=</span><span class="n">sample_width</span><span class="p">,</span>
                        <span class="n">sample_broadening</span><span class="o">=</span><span class="n">sample_broadening</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dT</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">== Instrument </span><span class="si">%(name)s</span><span class="s"> ==</span>
<span class="s">radiation = </span><span class="si">%(radiation)s</span><span class="s"> in %(L_min)g to %(L_max)g Angstrom with </span><span class="si">%(dLpercent)g%%</span><span class="s"> resolution</span>
<span class="s">slit distances = %(d_s1)g mm and %(d_s2)g mm</span>
<span class="s">slit openings = </span><span class="si">%(slits)s</span><span class="s"> mm</span>
<span class="s">sample width = %(sample_width)g mm</span>
<span class="s">sample broadening = %(sample_broadening)g degrees FWHM</span>
<span class="s">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span>
           <span class="n">L_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span> <span class="n">L_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span>
           <span class="n">dLpercent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="o">*</span><span class="mf">100</span><span class="p">,</span>
           <span class="n">d_s1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">,</span> <span class="n">slits</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slits</span><span class="p">),</span>
           <span class="n">sample_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">,</span>
           <span class="n">sample_broadening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">,</span>
           <span class="n">radiation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
           <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Pulsed.defaults"><a class="viewcode-back" href="../../api/instrument.html#refl1d.instrument.Pulsed.defaults">[docs]</a>    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return default instrument properties as a printable string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">== Instrument class </span><span class="si">%(name)s</span><span class="s"> ==</span>
<span class="s">radiation = </span><span class="si">%(radiation)s</span><span class="s"> in %(L_min)g to %(L_max)g Angstrom with </span><span class="si">%(dLpercent)g%%</span><span class="s"> resolution</span>
<span class="s">slit distances = %(d_s1)g mm and %(d_s2)g mm</span>
<span class="s">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span>
           <span class="n">L_min</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span> <span class="n">L_max</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span>
           <span class="n">dLpercent</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">dLoL</span><span class="o">*</span><span class="mf">100</span><span class="p">,</span>
           <span class="n">d_s1</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">d_s2</span><span class="p">,</span>
           <span class="n">radiation</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
           <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>
</div></div>
<span class="n">_</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">class GenericMonochromatic(Monochromatic):</span>
<span class="s">    def load(self, filename, **kw):</span>
<span class="s">        &quot;&quot;&quot;</span>
<span class="s">        Load the data, returning the associated probe.  This probe will</span>
<span class="s">        contain Q, angle, wavelength, measured reflectivity and the</span>
<span class="s">        associated uncertainties.</span>

<span class="s">        You can override instrument parameters using key=value.  In</span>
<span class="s">        particular, slit settings *slits_at_Tlo*, *Tlo*, *Thi*,</span>
<span class="s">        and *slits_below*, and *slits_above* are used to define the</span>
<span class="s">        angular divergence.</span>

<span class="s">        .. Note::</span>
<span class="s">             This function ignores any resolution information stored in</span>
<span class="s">             the file, such as dQ, dT or dL columns, and instead uses the</span>
<span class="s">             defined instrument parameters to calculate the resolution.</span>

<span class="s">        &quot;&quot;&quot;</span>
<span class="s">        # Load the data</span>
<span class="s">        data = numpy.loadtxt(filename).T</span>
<span class="s">        if data.shape[0] == 2:</span>
<span class="s">            Q,R = data</span>
<span class="s">            dR = None</span>
<span class="s">        elif data.shape[0] == 3:</span>
<span class="s">            Q,R,dR = data</span>
<span class="s">        elif data.shape[0] == 4:</span>
<span class="s">            Q,dQ,R,dR = data</span>
<span class="s">        elif data.shape[0] == 5:</span>
<span class="s">            Q,dQ,R,dR,L = data</span>
<span class="s">        if &quot;Q&quot; not in kw: kw[&quot;Q&quot;] = Q</span>
<span class="s">        T,dT,L,dL = self.resolution(**kw)</span>
<span class="s">        kw.update(dict(T=T,dT=dT,L=L,dL=dL,data=(R,dR),</span>
<span class="s">                       radiation=self.radiation))</span>
<span class="s">        return make_probe(**kw)</span>

<span class="s">class GenericPulsed(Pulsed):</span>
<span class="s">    def load(self, filename, **kw):</span>
<span class="s">        &quot;&quot;&quot;</span>
<span class="s">        Load the data, returning the associated probe.  This probe will</span>
<span class="s">        contain Q, angle, wavelength, measured reflectivity and the</span>
<span class="s">        associated uncertainties.</span>

<span class="s">        You can override instrument parameters using key=value.</span>
<span class="s">        In particular, slit settings *slits* and *T* define the</span>
<span class="s">        angular divergence.</span>
<span class="s">        &quot;&quot;&quot;</span>
<span class="s">        # Load the data</span>
<span class="s">        data = numpy.loadtxt(filename).T</span>
<span class="s">        Q,dQ,R,dR,L = data</span>
<span class="s">        dL = binwidths(L)</span>
<span class="s">        T = kw.pop(&#39;T&#39;,QL2T(Q,L))</span>
<span class="s">        T,dT,L,dL = self.resolution(L=L, dL=dL, T=T, **kw)</span>
<span class="s">        return make_probe(T=T,dT=dT,L=L,dL=dL,data=(R,dR),</span>
<span class="s">                          radiation=self.radiation, **kw)</span>
<span class="s">&#39;&#39;&#39;</span>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2006-2011, Paul Kienzle, Nikunj Patel, James Krycka.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>