

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refl1d.quasinewton &mdash; Refl1D v0.6.19 documentation</title>
    <link rel="stylesheet" href="../../_static/haiku-site.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.6.19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js"></script>
    <script type="text/javascript" src="../../_static/theme_extras.js"></script>
    <link rel="top" title="Refl1D v0.6.19 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="../../_static/logo.png" alt="Logo"/><h1 class="heading"><a href="../../index.html">
          <span>Refl1D v0.6.19 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.quasinewton</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for refl1d.quasinewton</h1><div class="highlight"><pre>
<span class="c"># Copyright (C) 2009-2010, University of Maryland</span>
<span class="c">#</span>
<span class="c"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c"># in the Software without restriction, including without limitation the rights</span>
<span class="c"># to use, copy, modify, merge, publish, distribute, sublicense, and/ or sell</span>
<span class="c"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c"># furnished to do so, subject to the following conditions:</span>
<span class="c">#</span>
<span class="c"># The above copyright notice and this permission notice shall be included in</span>
<span class="c"># all copies or substantial portions of the Software.</span>
<span class="c">#</span>
<span class="c"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="c"># THE SOFTWARE.</span>

<span class="c"># Author: Ismet Sahin</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">All modules in this file are implemented from the book</span>
<span class="sd">&quot;Numerical Methods for Unconstrained Optimization and Nonlinear Equations&quot; by</span>
<span class="sd">J.E. Dennis and Robert B. Schnabel (Only a few minor modifications are done).</span>

<span class="sd">EXAMPLE CALL::</span>

<span class="sd">    n = 2</span>
<span class="sd">    x0 = [-0.9 0.9]&#39;</span>
<span class="sd">    fn = lambda p: (1-p[0])**2 + 100*(p[1]-p[0]**2)**2</span>
<span class="sd">    grad = lambda p: array([-2*(1-p[0]) - 400*(p[1]-p[0]**2)*p[0], 200*p[1]])</span>
<span class="sd">    Sx = ones(n,1)</span>
<span class="sd">    typf = 1                       # todo. see what default value is the best</span>
<span class="sd">    macheps = eps</span>
<span class="sd">    eta = eps</span>
<span class="sd">    maxstep = 100</span>
<span class="sd">    gradtol = 1e-6</span>
<span class="sd">    steptol = 1e-12                # do not let steptol larger than 1e-9</span>
<span class="sd">    itnlimit = 1000</span>
<span class="sd">    result = quasinewton(fn, x0, grad, Sx, typf,</span>
<span class="sd">                         macheps, eta, maxstep, gradtol, steptol, itnlimit)</span>
<span class="sd">    print &quot;status code&quot;,result[&#39;status&#39;]</span>
<span class="sd">    print &quot;x_min, f(x_min)&quot;,result[&#39;x&#39;],result[&#39;fx&#39;]</span>
<span class="sd">    print &quot;iterations, function calls, linesearch function calls&quot;,\</span>
<span class="sd">          result[&#39;iterations&#39;],result[&#39;evals&#39;],result[&#39;linesearch_evals&#39;]</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s">&quot;quasinewton&quot;</span> <span class="p">]</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">inf</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">isnan</span><span class="p">,</span> <span class="n">isinf</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">diag</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">linalg</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">outer</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">maximum</span>

<span class="n">STATUS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mf">1</span><span class="p">:</span> <span class="s">&quot;Gradient &lt; tolerance&quot;</span><span class="p">,</span>
    <span class="mf">2</span><span class="p">:</span> <span class="s">&quot;Step size &lt; tolerance&quot;</span><span class="p">,</span>
    <span class="mf">3</span><span class="p">:</span> <span class="s">&quot;Invalid point in line search&quot;</span><span class="p">,</span>
    <span class="mf">4</span><span class="p">:</span> <span class="s">&quot;Iterations exceeded&quot;</span><span class="p">,</span>
    <span class="mf">5</span><span class="p">:</span> <span class="s">&quot;Max step taken --- function unbounded?&quot;</span><span class="p">,</span>
    <span class="mf">6</span><span class="p">:</span> <span class="s">&quot;User abort&quot;</span><span class="p">,</span>
    <span class="mf">7</span><span class="p">:</span> <span class="s">&quot;Iterations exceeded in line search&quot;</span><span class="p">,</span>
    <span class="mf">8</span><span class="p">:</span> <span class="s">&quot;Line search step size is too small&quot;</span><span class="p">,</span>
    <span class="mf">9</span><span class="p">:</span> <span class="s">&quot;Singular Hessian&quot;</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="quasinewton"><a class="viewcode-back" href="../../api/quasinewton.html#refl1d.quasinewton.quasinewton">[docs]</a><span class="k">def</span> <span class="nf">quasinewton</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">grad</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">Sx</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">typf</span> <span class="o">=</span> <span class="mf">1</span><span class="p">,</span> <span class="n">macheps</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">eta</span> <span class="o">=</span> <span class="p">[],</span>
              <span class="n">maxstep</span> <span class="o">=</span> <span class="mf">100</span><span class="p">,</span> <span class="n">gradtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">steptol</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="n">itnlimit</span> <span class="o">=</span> <span class="mf">2000</span><span class="p">,</span>
              <span class="n">monitor</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="bp">True</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a quasinewton optimization on the problem.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#print &quot;starting QN&quot;</span>
    <span class="c"># If some input parameters are not specified, define default values for them</span>
    <span class="c"># here. First and second parameters fn and x0 must be defined, others may be</span>
    <span class="c"># passed.  If you want to set a value to a parameter, say to typf, make sure all</span>
    <span class="c"># the parameters before this parameter are specified, in this case fn, x0, grad,</span>
    <span class="c"># and Sx if you want to have default values for grad and Sx, for each enter [].</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>            <span class="c"># important for also computing fcount (function count)</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">:</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grad</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">:</span>
        <span class="n">analgrad</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">analgrad</span> <span class="o">=</span> <span class="mf">1</span>

    <span class="k">if</span> <span class="n">Sx</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">:</span>
        <span class="n">Sx</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sx</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sizes of x0 and Sx must be the same&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">macheps</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">:</span>
        <span class="n">macheps</span> <span class="o">=</span> <span class="n">machineeps</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">eta</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">:</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">macheps</span>


    <span class="n">fcount</span> <span class="o">=</span> <span class="mf">0</span>                    <span class="c"># total function count</span>
    <span class="n">fcount_ls</span> <span class="o">=</span> <span class="mf">0</span>                <span class="c"># funciton count due to line search</span>

    <span class="c"># If analytic gradient is available then fn will return both function value and</span>
    <span class="c"># analytic gradient.  Otherwise, use finite difference method for estimating the</span>
    <span class="c"># gradient</span>
    <span class="k">if</span> <span class="n">analgrad</span> <span class="o">==</span> <span class="mf">1</span> <span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">fcount</span> <span class="o">=</span> <span class="n">fcount</span> <span class="o">+</span> <span class="mf">1</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">fdgrad</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
        <span class="n">fcount</span> <span class="o">=</span> <span class="n">fcount</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mf">1</span>



    <span class="c"># Check if the initial guess is a local minimizer</span>
    <span class="n">termcode</span> <span class="o">=</span> <span class="n">umstop0</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">typf</span><span class="p">,</span> <span class="n">gradtol</span><span class="p">)</span>
    <span class="n">consecmax</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">if</span> <span class="n">termcode</span> <span class="o">&gt;</span> <span class="mf">0</span> <span class="p">:</span>
        <span class="c"># Approximately x0 is a critical point</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">fc</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">inithessunfac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">typf</span><span class="p">,</span> <span class="n">Sx</span><span class="p">)</span>


    <span class="c"># STEP 9.</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">x0</span>

    <span class="c"># Iterate until convergence in the following loop</span>
    <span class="n">itncount</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">while</span> <span class="n">termcode</span> <span class="o">==</span> <span class="mf">0</span> <span class="p">:</span> <span class="c">#todo. increase itncount</span>
        <span class="c">#print &quot;update&quot;,itncount</span>
        <span class="n">itncount</span> <span class="o">=</span> <span class="n">itncount</span> <span class="o">+</span> <span class="mf">1</span>

        <span class="c"># disp([&#39;Iteration = &#39; num2str(itncount)])</span>
        <span class="c"># Find Newton step sN</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">modelhess</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">macheps</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="n">middle_step_v</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="n">gc</span><span class="p">)</span>              <span class="c"># the vector obtained in the middle</span>
        <span class="n">sN</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">middle_step_v</span><span class="p">)</span>   <span class="c"># the last step</span>
        <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="n">sN</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c">#print &quot;H&quot;,H</span>
            <span class="c">#print &quot;L&quot;,L</span>
            <span class="c">#print &quot;v&quot;,middle_step_v</span>
            <span class="c">#print &quot;Sx&quot;,Sx</span>
            <span class="c">#print &quot;gc&quot;,gc</span>
            <span class="n">termcode</span> <span class="o">=</span> <span class="mf">9</span>
            <span class="k">break</span>

        <span class="c"># Perform line search (Alg.6.3.1). todo. put param order as in the book</span>
        <span class="c">#print &quot;calling linesearch&quot;,xc,fc,gc,sN,Sx,H,L,middle_step_v</span>
        <span class="c">#print &quot;linesearch&quot;,xc,fc</span>
        <span class="n">retcode</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">maxtaken</span><span class="p">,</span> <span class="n">fcnt</span> \
            <span class="o">=</span> <span class="n">linesearch</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">sN</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">maxstep</span><span class="p">,</span> <span class="n">steptol</span><span class="p">)</span>
        <span class="n">fcount</span> <span class="o">=</span> <span class="n">fcount</span> <span class="o">+</span> <span class="n">fcnt</span>
        <span class="n">fcount_ls</span> <span class="o">=</span> <span class="n">fcount_ls</span> <span class="o">+</span> <span class="n">fcnt</span>
        <span class="c">#plot(xp(1), xp(2), &#39;g.&#39;)</span>

        <span class="c"># Evaluate gradient at new point xp</span>
        <span class="k">if</span> <span class="n">analgrad</span> <span class="o">==</span> <span class="mf">1</span> <span class="p">:</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">fdgrad</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
            <span class="n">fcount</span> <span class="o">=</span> <span class="n">fcount</span> <span class="o">+</span> <span class="n">n</span>

        <span class="c"># Check stopping criteria (alg.7.2.1)</span>
        <span class="n">consecmax</span> <span class="o">=</span> <span class="n">consecmax</span><span class="o">+</span><span class="mf">1</span> <span class="k">if</span> <span class="n">maxtaken</span> <span class="k">else</span> <span class="mf">0</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="n">umstop</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">typf</span><span class="p">,</span> <span class="n">retcode</span><span class="p">,</span> <span class="n">gradtol</span><span class="p">,</span>
                          <span class="n">steptol</span><span class="p">,</span> <span class="n">itncount</span><span class="p">,</span> <span class="n">itnlimit</span><span class="p">,</span> <span class="n">consecmax</span><span class="p">)</span>

        <span class="c"># STEP 10.6</span>
        <span class="c"># If termcode is larger than zero, we found a point satisfying one of the</span>
        <span class="c"># termination criteria, return from here.  Otherwise evaluate the next</span>
        <span class="c"># Hessian approximation (Alg. 9.4.1).</span>
        <span class="k">if</span> <span class="n">termcode</span> <span class="o">&gt;</span> <span class="mf">0</span> <span class="p">:</span>
            <span class="n">xf</span> <span class="o">=</span> <span class="n">xp</span>                                        <span class="c"># x final</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="n">fp</span>                                        <span class="c"># f final</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">monitor</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span><span class="n">fx</span><span class="o">=</span><span class="n">fp</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="n">itncount</span><span class="p">):</span>
            <span class="n">termcode</span> <span class="o">=</span> <span class="mf">6</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">bfgsunfac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">macheps</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">analgrad</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
            <span class="n">xc</span> <span class="o">=</span> <span class="n">xp</span>
            <span class="n">fc</span> <span class="o">=</span> <span class="n">fp</span>
            <span class="n">gc</span> <span class="o">=</span> <span class="n">gp</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="n">termcode</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xf</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="n">ff</span><span class="p">,</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">itncount</span><span class="p">,</span> <span class="n">evals</span><span class="o">=</span><span class="n">fcount</span><span class="p">,</span> <span class="n">linesearch_evals</span><span class="o">=</span><span class="n">fcount_ls</span><span class="p">)</span>

<span class="c">#------------------------------------------------------------------------------</span>
<span class="c">#@author: Ismet Sahin</span>
<span class="c"># Alg. 9.4.1</span>

<span class="c"># NOTE:</span>
<span class="c"># BFCG Hessian update is performed unless the following two conditions hold</span>
<span class="c">#    (i) y&#39;*s &lt; sqrt(macheps)*norm(s)*norm(y)</span>
<span class="c">#    (ii)</span></div>
<span class="k">def</span> <span class="nf">bfgsunfac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">macheps</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">analgrad</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">-</span> <span class="n">xc</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">gp</span> <span class="o">-</span> <span class="n">gc</span>
    <span class="n">temp1</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="c"># ISMET : I added condition of having temp1 != 0</span>
    <span class="k">if</span> <span class="n">temp1</span> <span class="o">&gt;=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">macheps</span><span class="p">)</span> <span class="o">*</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">temp1</span> <span class="o">!=</span> <span class="mf">0</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">analgrad</span> <span class="o">==</span> <span class="mf">1</span> <span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>

        <span class="c"># deal with noise levels in y</span>
        <span class="n">skipupdate</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">temp_logicals</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">maximum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">gc</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gp</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">temp_logicals</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">skipupdate</span> <span class="o">=</span> <span class="mf">0</span>

        <span class="c"># do the BFGS update if skipdate is false</span>
        <span class="k">if</span> <span class="n">skipupdate</span> <span class="o">==</span> <span class="mf">0</span> <span class="p">:</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">outer</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">temp1</span> <span class="o">-</span> <span class="n">outer</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">temp2</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="c">#------------------------------------------------------------------------------</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">@author: Ismet Sahin</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">choldecomp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">maxoffl</span><span class="p">,</span> <span class="n">macheps</span><span class="p">):</span>
    <span class="n">minl</span> <span class="o">=</span> <span class="p">(</span><span class="n">macheps</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxoffl</span>

    <span class="k">if</span> <span class="n">maxoffl</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
        <span class="c"># H is known to be a positive definite matrix</span>
        <span class="n">maxoffl</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">diag</span><span class="p">(</span><span class="n">H</span><span class="p">))))</span>

    <span class="n">minl2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">macheps</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxoffl</span>

    <span class="c"># 3. maxadd is the number (R) specifying the maximum amount added to any</span>
    <span class="c"># diagonal entry of Hessian matrix H</span>
    <span class="n">maxadd</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="c"># 4. form column j of L</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
        <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0</span><span class="p">:</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span>
        <span class="n">minljj</span> <span class="o">=</span> <span class="mf">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mf">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0</span><span class="p">:</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0</span><span class="p">:</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span>
            <span class="n">minljj</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]),</span> <span class="n">minljj</span><span class="p">)</span>

        <span class="c"># 4.4</span>
        <span class="n">minljj</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minljj</span><span class="o">/</span><span class="n">maxoffl</span><span class="p">,</span> <span class="n">minl</span><span class="p">)</span>

        <span class="c"># 4.5</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minljj</span><span class="o">**</span><span class="mf">2</span><span class="p">:</span>
            <span class="c"># normal Cholesky iteration</span>
            <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># augment H[j-1,j-1]</span>
            <span class="k">if</span> <span class="n">minljj</span> <span class="o">&lt;</span> <span class="n">minl2</span><span class="p">:</span>
                <span class="n">minljj</span> <span class="o">=</span> <span class="n">minl2</span>    <span class="c"># occurs only if maxoffl = 0</span>

            <span class="n">maxadd</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxadd</span><span class="p">,</span> <span class="n">minljj</span><span class="o">**</span><span class="mf">2</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span>
            <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minljj</span>

        <span class="c"># 4.6</span>
        <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>


    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">maxadd</span>

<span class="c">#------------------------------------------------------------------------------</span>
<span class="c"># ALGORITHM 5.6.3</span>

<span class="c"># Ismet Sahin</span>

<span class="c"># function g = fdgrad(n, xc, fc, objfunc, sx, eta)</span>
<span class="c"># g = fdgrad(@obj_function1, 2, [1 -1]&#39;, 10, [1 1], eps)</span>

<span class="c"># NOTATION:</span>
<span class="c">#    N : Natural number</span>
<span class="c">#    R : Real number</span>
<span class="c">#    Rn: nx1 real vector</span>
<span class="c">#    Rnxm : nxm real matrix</span>

<span class="c"># INPUTS:</span>
<span class="c">#    n  : the dimension of the gradient vector (N)</span>
<span class="c">#    xc : the current point at which the value of gradient is computed (Rn)</span>
<span class="c">#    fc : function value at xc (R)</span>
<span class="c">#    objfunc : a function handle which is used to compute function values</span>
<span class="c">#    Sx : a n-dim vector, jth entry specifies the typical value of jth param.</span>
<span class="c"># (Rn)</span>
<span class="c">#    eta: equals to 1e-DIGITS where DIGITS is an integer specifying the</span>
<span class="c"># number of reliable digits (R)</span>
<span class="c"># OUTPUT:</span>
<span class="c">#    g : the n-dim finite difference gradient vector (Rn)</span>

<span class="c"># NOTES :</span>
<span class="c">#    hj : is the constant specifying the step size in the direction of jth</span>
<span class="c"># coordinate (R)</span>
<span class="c">#    ej : the unit vector, jth column of the identity matrix (Rn)</span>

<span class="c"># COMMENTS:</span>
<span class="c">#--- FIND STEP SIZE hj</span>
<span class="c">#    1.a : sign(x) does not work for us when x = 0 since this makes the step</span>
<span class="c"># size hj zero which is not allowed. (Step size = 0 =&gt; gj = inf.)</span>
<span class="c">#    1.b : evaluation of the step size</span>
<span class="c">#    1.c : a trick to reduce error due to finite precision.  The line xc(j) =</span>
<span class="c"># xc(j) + hj is equivalent to xc = xc + hj * ej where ej is the jth column</span>
<span class="c"># of identity matrix.</span>
<span class="c">#</span>
<span class="c">#--- EVALUATE APPR. GRADIENT</span>
<span class="c"># First evaluate function at xc + hj * ej and then estimate jth entry of</span>
<span class="c"># the gradient.</span>

<span class="k">def</span> <span class="nf">fdgrad</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span> <span class="p">:</span>

    <span class="c"># create memory for gradient</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">sqrteta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">)</span> <span class="p">:</span>
        <span class="c">#--- FIND STEP SIZE hj</span>
        <span class="k">if</span> <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0</span> <span class="p">:</span>
            <span class="n">signxcj</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">signxcj</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1</span>                <span class="c"># 1.a</span>

        <span class="n">hj</span> <span class="o">=</span> <span class="n">sqrteta</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]),</span> <span class="mf">1</span><span class="o">/</span><span class="n">Sx</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">signxcj</span>                <span class="c"># 1.b</span>

        <span class="n">tempj</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>                                                                <span class="c"># 1.c</span>
        <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">hj</span>
        <span class="n">hj</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tempj</span>

        <span class="c">#--- EVALUATE APPR. GRADIENT</span>
        <span class="n">fj</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
        <span class="c"># PAK: hack for infeasible region: point the other way</span>
        <span class="k">if</span> <span class="n">isinf</span><span class="p">(</span><span class="n">fj</span><span class="p">):</span> <span class="n">fj</span> <span class="o">=</span> <span class="n">fc</span><span class="o">+</span><span class="n">hj</span>
        <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fj</span> <span class="o">-</span> <span class="n">fc</span><span class="p">)</span><span class="o">/</span><span class="n">hj</span>
        <span class="c">#if isinf(g[j-1]):</span>
        <span class="c">#    print &quot;fc,fj,hj,Sx,xc&quot;,fc,fj,hj,Sx[j-1],xc[j-1]</span>

        <span class="c"># now reset the current</span>
        <span class="n">xc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempj</span>

    <span class="k">return</span> <span class="n">g</span>


<span class="c">#------------------------------------------------------------------------------</span>
<span class="c"># @author: Ismet Sahin</span>
<span class="c"># Example call:</span>
<span class="c"># H = inithessunfac(2, f, 1, [1 0.1]&#39;)</span>

<span class="k">def</span> <span class="nf">inithessunfac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">typf</span><span class="p">,</span> <span class="n">Sx</span><span class="p">):</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">typf</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">temp</span> <span class="o">*</span> <span class="n">Sx</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span>


<span class="c">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">linesearch</span><span class="p">(</span><span class="n">cost_func</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">maxstep</span><span class="p">,</span> <span class="n">steptol</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">% ALGORITHM 6.3.1</span>
<span class="sd">%</span>
<span class="sd">% Ismet Sahin</span>

<span class="sd">% THE PURPOSE</span>
<span class="sd">%    is to find a step size which yields the new function value smaller than the</span>
<span class="sd">%    current function value, i.e. f(xc + alfa*p) &lt;= f(xc) + alfa * lambda * g&#39;p</span>

<span class="sd">% CONDITIONS</span>
<span class="sd">%    g&#39;p &lt; 0</span>
<span class="sd">%    alfa &lt; 0.5</span>

<span class="sd">% NOTATION:</span>
<span class="sd">%    N : Natural number</span>
<span class="sd">%    R : Real number</span>
<span class="sd">%    Rn: nx1 real vector</span>
<span class="sd">%    Rnxm : nxm real matrix</span>
<span class="sd">%    Str: a string</span>

<span class="sd">% INPUTS</span>
<span class="sd">%    n : dimensionality (N)</span>
<span class="sd">%    xc : the current point ( Rn)</span>
<span class="sd">%    fc : the function value at xc (R)</span>
<span class="sd">%    obj_func : the function handle to evaluate function values (str like :</span>
<span class="sd">%       &#39;@costfunction1&#39;)</span>
<span class="sd">%    g : gradient (Rn)</span>
<span class="sd">%    p : the descent direction (Rn)</span>
<span class="sd">%    Sx : scale factors (Rn)</span>
<span class="sd">%    maxstep : maximum step size allowed (R)</span>
<span class="sd">%    steptol : step tolerance in order to break infinite loop in line search (R)</span>

<span class="sd">% OUTPUTS</span>
<span class="sd">%    retcode : boolean indicating a new point xp found (0) or not (1)    (N).</span>
<span class="sd">%    xp : the new point (Rn)</span>
<span class="sd">%    fp : function value at xp (R)</span>
<span class="sd">%    maxtaken : boolean (N)</span>

<span class="sd">% NOTES:</span>
<span class="sd">%    alfa : is used to prevent function value reductions which are too small.</span>
<span class="sd">%       Here we&#39;ll use a very small number in order to accept very small</span>
<span class="sd">%       reductions but not too small.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">maxtaken</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="c"># alfa specifies how much function value reduction is allowable.  The smaller</span>
    <span class="c"># the alfa, the smaller the function value reduction we allow.</span>
    <span class="n">alfa</span> <span class="o">=</span> <span class="mf">1e-4</span>

    <span class="c"># the magnitude of the Newton step</span>
    <span class="n">Newtlen</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Sx</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Newtlen</span> <span class="o">&gt;</span> <span class="n">maxstep</span><span class="p">:</span>
        <span class="c"># Newton step is larger than the maximum acceptable step size (maxstep). Make</span>
        <span class="c"># it equal or smaller than maxstep</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxstep</span> <span class="o">/</span> <span class="n">Newtlen</span><span class="p">)</span>
        <span class="n">Newtlen</span> <span class="o">=</span> <span class="n">maxstep</span>

    <span class="n">initslope</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c"># &quot;Relative length of p as calculated in the stopping routine&quot;</span>
    <span class="c"># rellength = amax(abs(p) / maximum(abs(xc), Sx))    # this was a bug</span>
    <span class="n">rellength</span> <span class="o">=</span> <span class="n">amax</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">maximum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xc</span><span class="p">),</span> <span class="mf">1</span><span class="o">/</span><span class="n">Sx</span><span class="p">))</span>

    <span class="n">minlambda</span> <span class="o">=</span> <span class="n">steptol</span> <span class="o">/</span> <span class="n">rellength</span>

    <span class="n">lambdaM</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c"># In this loop, we try to find an acceptable next point xp = xc + lambda * p by</span>
    <span class="c"># finding an optimal lambda based on one dimensional quadratic and cubic models</span>
    <span class="n">fcount</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>                <span class="c"># 10 starts.</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">lambdaM</span> <span class="o">*</span> <span class="n">p</span>                                    <span class="c"># next point candidate</span>
        <span class="c">#print &quot;linesearch&quot;,fcount,xp,xc,lambdaM,p</span>
        <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c">#print &quot;linesearch&quot;,fcount,xp,xc,lambdaM,p</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="n">xp</span><span class="p">,</span><span class="n">fp</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span><span class="n">fc</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">fcount</span> <span class="o">&gt;</span> <span class="mf">20</span><span class="p">:</span>
            <span class="c">#print &quot;too many cycles in linesearch&quot;,xp</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="mf">2</span>
            <span class="n">xp</span><span class="p">,</span><span class="n">fp</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span><span class="n">fc</span>
            <span class="k">break</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">cost_func</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>                                        <span class="c"># function value at xp</span>
        <span class="k">if</span> <span class="n">isinf</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span> <span class="n">fp</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">fc</span> <span class="c"># PAK: infeasible region hack</span>
        <span class="n">fcount</span> <span class="o">=</span> <span class="n">fcount</span> <span class="o">+</span> <span class="mf">1</span>
        <span class="k">if</span> <span class="n">fp</span> <span class="o">&lt;=</span> <span class="n">fc</span> <span class="o">+</span> <span class="n">alfa</span> <span class="o">*</span> <span class="n">lambdaM</span> <span class="o">*</span> <span class="n">initslope</span><span class="p">:</span>
            <span class="c"># satisfactory xp is found</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">if</span> <span class="n">lambdaM</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">Newtlen</span> <span class="o">&gt;</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="n">maxstep</span><span class="p">:</span>
                <span class="n">maxtaken</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="k">break</span>                                                    <span class="c"># return from here</span>
        <span class="k">elif</span> <span class="n">lambdaM</span> <span class="o">&lt;</span> <span class="n">minlambda</span><span class="p">:</span>
            <span class="c"># step length is too small, therefore a satisfactory xp cannot be found</span>
            <span class="c">#print &quot;step&quot;,lambdaM,minlambda,steptol,rellength</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="mf">3</span>
            <span class="n">xp</span><span class="p">,</span><span class="n">fp</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span><span class="n">fc</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>                            <span class="c"># 10.3c starts</span>
            <span class="c"># reduce lambda by a factor between 0.1 and 0.5</span>
            <span class="k">if</span> <span class="n">lambdaM</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="c"># first backtrack with one dimensional quadratic fit</span>
                <span class="n">lambda_temp</span> <span class="o">=</span> <span class="o">-</span><span class="n">initslope</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">fp</span><span class="o">-</span><span class="n">fc</span><span class="o">-</span><span class="n">initslope</span><span class="p">))</span>
                <span class="c">#print &quot;L1&quot;,lambda_temp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># perform second and following backtracks with cubic fit</span>
                <span class="n">Mt</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">lambdaM</span><span class="o">**</span><span class="mf">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">lambda_prev</span><span class="o">**</span><span class="mf">2</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="n">lambda_prev</span><span class="o">/</span><span class="p">(</span><span class="n">lambdaM</span><span class="o">**</span><span class="mf">2</span><span class="p">),</span> <span class="n">lambdaM</span><span class="o">/</span><span class="p">(</span><span class="n">lambda_prev</span><span class="o">**</span><span class="mf">2</span><span class="p">)]])</span>
                <span class="n">vt</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="n">fp</span> <span class="o">-</span> <span class="n">fc</span> <span class="o">-</span> <span class="n">lambdaM</span> <span class="o">*</span> <span class="n">initslope</span><span class="p">],</span> <span class="p">[</span><span class="n">fp_prev</span> <span class="o">-</span> <span class="n">fc</span> <span class="o">-</span> <span class="n">lambda_prev</span> <span class="o">*</span> <span class="n">initslope</span><span class="p">]])</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">lambdaM</span><span class="o">-</span><span class="n">lambda_prev</span><span class="p">))</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span><span class="n">vt</span><span class="p">)</span>
                <span class="n">disc</span> <span class="o">=</span> <span class="n">ab</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2</span> <span class="o">-</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">initslope</span>        <span class="c"># a = ab(1) and b = ab(2)</span>
                <span class="c">#print &quot;Mt,vt,ab,disc&quot;,Mt,vt,ab,disc</span>
                <span class="k">if</span> <span class="n">ab</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c"># cubic model turn out to be a quadratic</span>
                    <span class="n">lambda_temp</span> <span class="o">=</span> <span class="o">-</span><span class="n">initslope</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">])</span>
                    <span class="c">#print &quot;L2&quot;,lambda_temp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># the model is a legitimate cubic</span>
                    <span class="n">lambda_temp</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">ab</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">disc</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">])</span>
                    <span class="c">#print &quot;L3&quot;,lambda_temp</span>

                <span class="k">if</span> <span class="n">lambda_temp</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lambdaM</span><span class="p">:</span>
                    <span class="c"># larger than half of previous lambda is not allowed.</span>
                    <span class="n">lambda_temp</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lambdaM</span>
                    <span class="c">#print &quot;L4&quot;,lambda_temp</span>

            <span class="n">lambda_prev</span> <span class="o">=</span> <span class="n">lambdaM</span>
            <span class="n">fp_prev</span> <span class="o">=</span> <span class="n">fp</span>
            <span class="k">if</span> <span class="n">lambda_temp</span> <span class="o">&lt;=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">lambdaM</span><span class="p">:</span>
                <span class="c"># smaller than 1/10 th of previous lambda is not allowed.</span>
                <span class="n">lambdaM</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">lambdaM</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambdaM</span> <span class="o">=</span> <span class="n">lambda_temp</span>

            <span class="c">#print &#39;lambda = &#39;, lambdaM</span>

    <span class="c"># return xp, fp, retcode</span>
    <span class="k">return</span> <span class="n">retcode</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">maxtaken</span><span class="p">,</span> <span class="n">fcount</span>


<span class="c">#------------------------------------------------------------------------------</span>

<span class="c"># @author: Ismet Sahin</span>
<span class="c"># ALGORITHM 1.3.1</span>
<span class="k">def</span> <span class="nf">machineeps</span><span class="p">()</span> <span class="p">:</span>
    <span class="n">macheps</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">macheps</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">1</span> <span class="p">:</span>
        <span class="n">macheps</span> <span class="o">=</span> <span class="n">macheps</span> <span class="o">/</span> <span class="mf">2</span>

    <span class="n">macheps</span> <span class="o">=</span> <span class="mf">2</span> <span class="o">*</span> <span class="n">macheps</span>
    <span class="k">return</span> <span class="n">macheps</span>


<span class="c">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">modelhess</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">macheps</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">@author: Ismet Sahin.</span>
<span class="sd">Thanks to Christopher Meeting for his help in converting this module from</span>
<span class="sd">Matlab to Python</span>

<span class="sd"># ALGORITHM 5.5.1</span>

<span class="sd">% NOTES:</span>
<span class="sd">%    Currently we are not implementing steps 1, 14, and 15 (TODO)</span>

<span class="sd">% This function performs perturbed Cholesky decomposition (CD) as if the input</span>
<span class="sd">% Hessian matrix is positive definite.  The code for perturbed CD resides in</span>
<span class="sd">% choldecomp.m file which returns the factored lower triangle matrix L and a</span>
<span class="sd">% number, maxadd, specifying the largest number added to a diagonal element of H</span>
<span class="sd">% during the CD decomposition.  This function checks if the decomposition is</span>
<span class="sd">% completed without adding any positive number to the diagonal elements of H,</span>
<span class="sd">% i.e. maxadd &lt;= 0.  Otherwise, this function adds the least number to the</span>
<span class="sd">% diagonals of H which makes it positive definite based on maxadd and other</span>
<span class="sd">% entries in H.</span>
<span class="sd"># EXAMPLE CALLS:</span>
<span class="sd">%         A1 =[2     0    2.4</span>
<span class="sd">%               0     2     0</span>
<span class="sd">%              2.4     0     3]</span>
<span class="sd">%</span>
<span class="sd">%         A2 =[2     0    2.5</span>
<span class="sd">%               0     2     0</span>
<span class="sd">%              2.5     0     3]</span>
<span class="sd">%</span>
<span class="sd">%         A3 =[2     0    10</span>
<span class="sd">%               0     2     0</span>
<span class="sd">%              10     0     3]</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># SCALING</span>
    <span class="n">scale_needed</span> <span class="o">=</span> <span class="mf">0</span>                        <span class="c"># ISMET uses this parameter</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Sx</span> <span class="o">-</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">!=</span> <span class="mf">0</span> <span class="p">:</span>
        <span class="c"># scaling is requested by the user</span>
        <span class="n">scale_needed</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="n">Dx</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">Sx</span><span class="p">)</span>
        <span class="n">Dx_inv</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">Sx</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">Dx_inv</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Dx_inv</span><span class="p">))</span>

    <span class="c"># STEP I.</span>
    <span class="n">sqrteps</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">macheps</span><span class="p">)</span>

    <span class="c">#2-4.</span>
    <span class="n">H_diag</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">maxdiag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">H_diag</span><span class="p">)</span>
    <span class="n">mindiag</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">H_diag</span><span class="p">)</span>

    <span class="c"># 5.</span>
    <span class="n">maxposdiag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">maxdiag</span><span class="p">)</span>

    <span class="c"># 6. mu is the amount to be added to diagonal of H before the Cholesky decomp.</span>
    <span class="c"># If the minimum diagonal is much much smaller than the maximum diagonal element</span>
    <span class="c"># then adjust mu accordingly otherwise mu = 0.</span>
    <span class="k">if</span> <span class="n">mindiag</span> <span class="o">&lt;=</span> <span class="n">sqrteps</span> <span class="o">*</span> <span class="n">maxposdiag</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mf">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxposdiag</span> <span class="o">-</span> <span class="n">mindiag</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrteps</span> <span class="o">-</span> <span class="n">mindiag</span>
        <span class="n">maxdiag</span> <span class="o">=</span> <span class="n">maxdiag</span> <span class="o">+</span> <span class="n">mu</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="c"># 7. maximum of off-diagonal elements of H</span>
    <span class="n">diag_infinite</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">inf</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">maxoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span> <span class="o">-</span> <span class="n">diag_infinite</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c"># 8. if maximum off diagonal element is much much larger than the maximum</span>
    <span class="c"># diagonal element of the Hessian H</span>
    <span class="k">if</span> <span class="n">maxoff</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1</span> <span class="o">+</span> <span class="mf">2</span> <span class="o">*</span> <span class="n">sqrteps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxdiag</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="p">(</span><span class="n">maxoff</span> <span class="o">-</span> <span class="n">maxdiag</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2</span> <span class="o">*</span> <span class="n">sqrteps</span> <span class="o">*</span> <span class="n">maxoff</span>
        <span class="n">maxdiag</span> <span class="o">=</span> <span class="n">maxoff</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1</span> <span class="o">+</span> <span class="mf">2</span> <span class="o">*</span> <span class="n">sqrteps</span><span class="p">)</span>

    <span class="c"># 9.</span>
    <span class="k">if</span> <span class="n">maxdiag</span> <span class="o">==</span> <span class="mf">0</span> <span class="p">:</span>            <span class="c"># if H == 0</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="n">maxdiag</span> <span class="o">=</span> <span class="mf">1</span>

    <span class="c"># 10. mu&gt;0 =&gt; need to add mu amount to the diagonal elements: H = H + mu*I</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">:</span>
        <span class="n">diag_mu</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">diag_mu</span>

    <span class="c"># 11.</span>
    <span class="n">maxoffl</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">maxdiag</span><span class="p">,</span> <span class="n">maxoff</span><span class="o">/</span><span class="n">n</span><span class="p">))</span>

    <span class="c"># STEP II. Perform perturbed Cholesky decomposition H + D = LL&#39; where D is a</span>
    <span class="c"># diagonal matrix which is implicitly added to H if H is not positive definite.</span>
    <span class="c"># Matrix D has only positive elements. The output variable maxadd indicates the</span>
    <span class="c"># maximum number added to a diagonal entry of the Hesian, i.e. the maximum of D.</span>
    <span class="c"># If maxadd is returned 0, then H was indeed pd and L is the resulting factor.</span>
    <span class="c"># 12.</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">maxadd</span> <span class="o">=</span> <span class="n">choldecomp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">maxoffl</span><span class="p">,</span> <span class="n">macheps</span><span class="p">)</span>

    <span class="c"># STEP III.</span>
    <span class="c"># 13. If maxadd &lt;= 0, we are done H was positive definite.</span>
    <span class="k">if</span> <span class="n">maxadd</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">:</span>
        <span class="c"># H was not positive definite</span>
        <span class="c">#print &#39;WARNING: Hessian is not pd. Max number added to H is &#39;, maxadd, &#39;\n&#39;</span>
        <span class="n">maxev</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">minev</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
            <span class="n">offrow</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mf">0</span><span class="p">:</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">]))</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span><span class="n">n</span><span class="p">]))</span>
            <span class="n">maxev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxev</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offrow</span><span class="p">)</span>
            <span class="n">minev</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minev</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offrow</span><span class="p">)</span>

        <span class="n">sdd</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxev</span> <span class="o">-</span> <span class="n">minev</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrteps</span> <span class="o">-</span> <span class="n">minev</span>
        <span class="n">sdd</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sdd</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxadd</span><span class="p">,</span> <span class="n">sdd</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">diag</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">maxadd</span> <span class="o">=</span> <span class="n">choldecomp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="n">macheps</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scale_needed</span> <span class="p">:</span>                <span class="c"># todo. this calculation can be done faster</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">Dx</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Dx</span><span class="p">))</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">Dx</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">L</span>


<span class="c">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">umstop</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">typf</span><span class="p">,</span> <span class="n">retcode</span><span class="p">,</span> <span class="n">gradtol</span><span class="p">,</span> <span class="n">steptol</span><span class="p">,</span>
           <span class="n">itncount</span><span class="p">,</span> <span class="n">itnlimit</span><span class="p">,</span> <span class="n">consecmax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">#@author: Ismet Sahin</span>

<span class="sd">ALGORITHM 7.2.1</span>

<span class="sd">Return codes:</span>
<span class="sd">Note that return codes are nonnegative integers. When it is not zero, there is</span>
<span class="sd">a termination condition which is satisfied.</span>
<span class="sd">   0 : None of the termination conditions is satisfied</span>
<span class="sd">   1 : Magnitute of scaled grad is less than gradtol; this is the primary</span>
<span class="sd">       condition. The new point xp is most likely a local minimizer.  If gradtol</span>
<span class="sd">       is too large, then this condition can be satisfied easier and therefore</span>
<span class="sd">       xp may not be a local minimizer</span>
<span class="sd">   2 : Scaled distance between last two points is less than steptol; xp might be</span>
<span class="sd">       a local minimizer.  This condition may also be satisfied if step is</span>
<span class="sd">       chosen too large or the algorithm is far from the minimizer and making</span>
<span class="sd">       small progress</span>
<span class="sd">   3 : The algorithm cannot find a new point giving smaller function value than</span>
<span class="sd">       the current point.  The current may be a local minimizer, or analytic</span>
<span class="sd">       gradient implementation has some mistakes, or finite difference gradient</span>
<span class="sd">       estimation is not accurate, or steptol is too large.</span>
<span class="sd">   4 : Maximum number of iterations are completed</span>
<span class="sd">   5 : The maximum step length maxstep is taken for last ten consecutive</span>
<span class="sd">       iterations.  This may happen if the funtion is not bounded from below, or</span>
<span class="sd">       the function has a finite asympotote in some direction, or maxstep is too</span>
<span class="sd">       small.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">termcode</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">if</span> <span class="n">retcode</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">3</span>
    <span class="k">elif</span> <span class="n">retcode</span> <span class="o">==</span> <span class="mf">2</span><span class="p">:</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">7</span>
    <span class="k">elif</span> <span class="n">retcode</span> <span class="o">==</span> <span class="mf">3</span><span class="p">:</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">8</span>
    <span class="k">elif</span> <span class="n">retcode</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unknown linesearch return code&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">maximum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xp</span><span class="p">),</span> <span class="mf">1</span><span class="o">/</span><span class="n">Sx</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">typf</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">gradtol</span><span class="p">:</span>
        <span class="c"># maximum component of scaled gradient is smaller than gradtol.  todo. make</span>
        <span class="c"># sure not to use a too large typf value which leads to the satisfaction of</span>
        <span class="c"># this algorithm easily.</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">1</span>
    <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xp</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span> <span class="o">/</span> <span class="n">maximum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xp</span><span class="p">),</span> <span class="mf">1</span><span class="o">/</span><span class="n">Sx</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">steptol</span><span class="p">:</span>
        <span class="c"># maximum component of scaled step is smaller than steptol</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">2</span>
    <span class="k">elif</span> <span class="n">itncount</span> <span class="o">&gt;=</span> <span class="n">itnlimit</span><span class="p">:</span>
        <span class="c"># maximum number of iterations are performed</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">4</span>
    <span class="k">elif</span> <span class="n">consecmax</span> <span class="o">==</span> <span class="mf">10</span><span class="p">:</span>
        <span class="c"># not more than 10 steps will be taken consecutively.</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">5</span>

    <span class="k">return</span> <span class="n">termcode</span>



<span class="c">#------------------------------------------------------------------------------</span>
<span class="c">#@author: Ismet Sahin</span>

<span class="c"># This function checks whether initial conditions are acceptable for</span>
<span class="c"># continuing unconstrained optimization</span>

<span class="c"># f : the function value at x0, i.e. f = f(x0),  (R)</span>
<span class="c"># g : the gradient at x0, (Rn)</span>

<span class="c"># termcode = 0 : x0 is not a critical point of f(x), (Z)</span>
<span class="c"># termcode = 1 : x0 is a critical point of f(x), (Z)</span>

<span class="c"># Note that x0 may be a critical point of the function; in this case, it is</span>
<span class="c"># either a local minimizer or a saddle point of the function.  If the Hessian at</span>
<span class="c"># x0 is positive definite than it is indeed a local minimizer.  Instead of</span>
<span class="c"># checking Hessian, we can also restart the driver program umexample from</span>
<span class="c"># another point which is close to x0.  If x0 is the local minimizer, the</span>
<span class="c"># algorithm will approach it.</span>

<span class="k">def</span> <span class="nf">umstop0</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">Sx</span><span class="p">,</span> <span class="n">typf</span><span class="p">,</span> <span class="n">gradtol</span><span class="p">):</span>
    <span class="n">consecmax</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">maximum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="mf">1</span><span class="o">/</span><span class="n">Sx</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">typf</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">gradtol</span> <span class="p">:</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">1</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">termcode</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">return</span> <span class="n">termcode</span>


<span class="c">#------------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">example_call</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;***********************************&#39;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mf">2</span><span class="p">;</span>

    <span class="c"># Rosenbrock function</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span><span class="o">**</span><span class="mf">2</span> <span class="o">+</span> <span class="mf">100</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span><span class="o">-</span><span class="mf">400</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mf">0</span><span class="p">],</span> <span class="mf">200</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2</span><span class="p">)])</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mf">2.320894</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.534223</span><span class="p">])</span>
    <span class="c"># x0 = array([2.0,1.0])</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">quasinewton</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">fn</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="n">grad</span><span class="p">)</span>
    <span class="c">#result = quasinewton(fn=fn, x0=x0)</span>

    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n\n</span><span class="s">Initial point x0 = &#39;</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="s">&#39;, f(x0) = &#39;</span><span class="p">,</span> <span class="n">fn</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span> <span class="k">print</span> <span class="n">k</span><span class="p">,</span><span class="s">&quot;=&quot;</span><span class="p">,</span><span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span> <span class="n">example_call</span><span class="p">()</span>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2006-2011, Paul Kienzle, Nikunj Patel, James Krycka.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>