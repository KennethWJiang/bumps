

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refl1d.resolution &mdash; Refl1D v0.6.19 documentation</title>
    <link rel="stylesheet" href="../../_static/haiku-site.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.6.19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js"></script>
    <script type="text/javascript" src="../../_static/theme_extras.js"></script>
    <link rel="top" title="Refl1D v0.6.19 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="../../_static/logo.png" alt="Logo"/><h1 class="heading"><a href="../../index.html">
          <span>Refl1D v0.6.19 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.resolution</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for refl1d.resolution</h1><div class="highlight"><pre>
<span class="s">r&quot;&quot;&quot;</span>
<span class="s">Resolution calculations</span>

<span class="s">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">radians</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arcsin</span> <span class="k">as</span> <span class="n">asin</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">clip</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ones_like</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">hstack</span>

<div class="viewcode-block" id="QL2T"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.QL2T">[docs]</a><span class="k">def</span> <span class="nf">QL2T</span><span class="p">(</span><span class="n">Q</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Compute angle from $Q$ and wavelength.</span>

<span class="s">    .. math::</span>

<span class="s">        \theta = \sin^{-1}( |Q| \lambda / 4 \pi )</span>

<span class="s">    Returns $\theta$\ |deg|.</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="n">Q</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">degrees</span><span class="p">(</span><span class="n">asin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4</span><span class="o">*</span><span class="n">pi</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="TL2Q"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.TL2Q">[docs]</a><span class="k">def</span> <span class="nf">TL2Q</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Compute $Q$ from angle and wavelength.</span>

<span class="s">    .. math::</span>

<span class="s">        Q = 4 \pi \sin(\theta) / \lambda</span>

<span class="s">    Returns $Q$ |1/Ang|</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="n">T</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">L</span>
</div>
<span class="n">_FWHM_scale</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mf">256</span><span class="p">))</span>
<div class="viewcode-block" id="FWHM2sigma"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.FWHM2sigma">[docs]</a><span class="k">def</span> <span class="nf">FWHM2sigma</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">/</span><span class="n">_FWHM_scale</span></div>
<div class="viewcode-block" id="sigma2FWHM"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.sigma2FWHM">[docs]</a><span class="k">def</span> <span class="nf">sigma2FWHM</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">*</span><span class="n">_FWHM_scale</span>

</div>
<div class="viewcode-block" id="dTdL2dQ"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.dTdL2dQ">[docs]</a><span class="k">def</span> <span class="nf">dTdL2dQ</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dT</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Convert wavelength dispersion and angular divergence to $Q$ resolution.</span>

<span class="s">    *T*,*dT*  (degrees) angle and FWHM angular divergence</span>
<span class="s">    *L*,*dL*  (Angstroms) wavelength and FWHM wavelength dispersion</span>

<span class="s">    Returns 1-\ $\sigma$ $\Delta Q$</span>
<span class="s">    &quot;&quot;&quot;</span>

    <span class="c"># Compute dQ from wavelength dispersion (dL) and angular divergence (dT)</span>
    <span class="n">T</span><span class="p">,</span><span class="n">dT</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)),</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">dT</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">))</span>
    <span class="n">L</span><span class="p">,</span><span class="n">dL</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">),</span><span class="n">asarray</span><span class="p">(</span><span class="n">dL</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="c">#print T, dT, L, dL</span>
    <span class="n">dQ</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">dL</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">dT</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span> <span class="p">)</span>

    <span class="c">#sqrt((dL/L)**2+(radians(dT)/tan(radians(T)))**2)*probe.Q</span>
    <span class="k">return</span> <span class="n">FWHM2sigma</span><span class="p">(</span><span class="n">dQ</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="dQdT2dLoL"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.dQdT2dLoL">[docs]</a><span class="k">def</span> <span class="nf">dQdT2dLoL</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">dQ</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Convert a calculated Q resolution and angular divergence to a</span>
<span class="s">    wavelength dispersion.</span>

<span class="s">    *Q*, *dQ* |1/Ang|  $Q$ and 1-\ $\sigma$ $Q$ resolution</span>
<span class="s">    *T*, *dT* |deg| angle and FWHM angular divergence</span>

<span class="s">    Returns FWHM $\Delta\lambda/\lambda$</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="n">T</span><span class="p">,</span><span class="n">dT</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)),</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">dT</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">))</span>
    <span class="n">Q</span><span class="p">,</span><span class="n">dQ</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">),</span><span class="n">asarray</span><span class="p">(</span><span class="n">dQ</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">sigma2FWHM</span><span class="p">(</span><span class="n">dQ</span><span class="p">)</span><span class="o">/</span><span class="n">Q</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">dT</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">T</span><span class="p">))</span><span class="o">**</span><span class="mf">2</span> <span class="p">)</span>


</div>
<div class="viewcode-block" id="dQdL2dT"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.dQdL2dT">[docs]</a><span class="k">def</span> <span class="nf">dQdL2dT</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">dQ</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Convert a calculated Q resolution and wavelength dispersion to</span>
<span class="s">    angular divergence.</span>

<span class="s">    *Q*, *dQ* |1/Ang|  $Q$ and 1-\ $\sigma$ $Q$ resolution</span>
<span class="s">    *L*, *dL* |deg| angle and FWHM angular divergence</span>

<span class="s">    Returns FWHM $\theta, \Delta\theta$</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="n">L</span><span class="p">,</span><span class="n">dL</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">),</span><span class="n">asarray</span><span class="p">(</span><span class="n">dL</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">Q</span><span class="p">,</span><span class="n">dQ</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">),</span><span class="n">asarray</span><span class="p">(</span><span class="n">dQ</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
    <span class="n">dT</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">sigma2FWHM</span><span class="p">(</span><span class="n">dQ</span><span class="p">)</span><span class="o">/</span><span class="n">Q</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">dL</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span><span class="n">dT</span>

</div>
<span class="n">Plancks_constant</span><span class="o">=</span><span class="mf">6.62618e-27</span> <span class="c"># Planck constant (erg*sec)</span>
<span class="n">neutron_mass</span><span class="o">=</span><span class="mf">1.67495e-24</span><span class="p">;</span>    <span class="c"># neutron mass (g)</span>
<div class="viewcode-block" id="TOF2L"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.TOF2L">[docs]</a><span class="k">def</span> <span class="nf">TOF2L</span><span class="p">(</span><span class="n">d_moderator</span><span class="p">,</span> <span class="n">TOF</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Convert neutron time-of-flight to wavelength.</span>

<span class="s">    .. math::</span>

<span class="s">        \lambda = (t/d) (h/n_m)</span>

<span class="s">    where:</span>

<span class="s">        | $\lambda$ is wavelength in |Ang|</span>
<span class="s">        | $t$ is time-of-flight in $u$\s</span>
<span class="s">        | $h$ is Planck&#39;s constant in erg seconds</span>
<span class="s">        | $n_m$ is the neutron mass in g</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">TOF</span><span class="o">*</span><span class="p">(</span><span class="n">Plancks_constant</span><span class="o">/</span><span class="n">neutron_mass</span><span class="o">/</span><span class="n">d_moderator</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="bins"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.bins">[docs]</a><span class="k">def</span> <span class="nf">bins</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">dLoL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return bin centers from low to high preserving a fixed resolution.</span>

<span class="sd">    *low*, *high* are the minimum and maximum wavelength.</span>
<span class="sd">    *dLoL* is the desired resolution FWHM $\Delta\lambda/\lambda$ for the bins.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">step</span> <span class="o">=</span> <span class="mf">1</span> <span class="o">+</span> <span class="n">dLoL</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">high</span><span class="o">/</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">low</span><span class="o">*</span><span class="n">step</span><span class="o">**</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span><span class="o">+</span><span class="n">edges</span><span class="p">[</span><span class="mf">1</span><span class="p">:])</span><span class="o">/</span><span class="mf">2</span>
    <span class="k">return</span> <span class="n">L</span>
</div>
<div class="viewcode-block" id="binwidths"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.binwidths">[docs]</a><span class="k">def</span> <span class="nf">binwidths</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Determine the wavelength dispersion from bin centers *L*.</span>

<span class="s">    The wavelength dispersion $\Delta\lambda$ is just the difference</span>
<span class="s">    between consecutive bin edges, so:</span>

<span class="s">    .. math::</span>

<span class="s">        \Delta L_i  = E_{i+1}-E_{i}</span>
<span class="s">                    = (1+\omega) E_i - E_i</span>
<span class="s">                    = \omega E_i</span>
<span class="s">                    = \frac{2 \omega}{2+\omega} L_i</span>

<span class="s">    where $E$ and $\omega$ are as defined in :func:`binedges`.</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="mf">0</span><span class="p">]:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">/</span><span class="n">L</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">/</span><span class="n">L</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1</span>
    <span class="n">dL</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">dLoL</span><span class="o">/</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="n">dLoL</span><span class="p">)</span><span class="o">*</span><span class="n">L</span>
    <span class="k">return</span> <span class="n">dL</span>
</div>
<div class="viewcode-block" id="binedges"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.binedges">[docs]</a><span class="k">def</span> <span class="nf">binedges</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Construct bin edges *E* from bin centers *L*.</span>

<span class="s">    Assuming fixed $\omega = \Delta\lambda/\lambda$ in the bins, the</span>
<span class="s">    edges will be spaced logarithmically at:</span>

<span class="s">    .. math::</span>

<span class="s">        E_0     &amp;= \min \lambda \\</span>
<span class="s">        E_{i+1} &amp;= E_i + \omega E_i = E_i (1+\omega)</span>

<span class="s">    with centers $L$ half way between the edges:</span>

<span class="s">    .. math::</span>

<span class="s">        L_i = (E_i+E_{i+1})/2</span>
<span class="s">            = (E_i + E_i (1+\omega))/2</span>
<span class="s">            = E_i (2 + \omega)/2</span>

<span class="s">    Solving for $E_i$, we can recover the edges from the centers:</span>

<span class="s">    .. math::</span>

<span class="s">        E_i = L_i \frac{2}{2+\omega}</span>

<span class="s">    The final edge, $E_{n+1}$, does not have a corresponding center</span>
<span class="s">    $L_{n+1}$ so we must determine it from the previous edge $E_n$:</span>

<span class="s">    .. math::</span>

<span class="s">        E_{n+1} = L_n \frac{2}{2+\omega}(1+\omega)</span>

<span class="s">    The fixed $\omega$ can be retrieved from the ratio of any pair</span>
<span class="s">    of bin centers using:</span>

<span class="s">    .. math::</span>

<span class="s">        \frac{L_{i+1}}{L_i} = \frac{ (E_{i+2}+E_{i+1})/2 }{ (E_{i+1}+E_i)/2 }</span>
<span class="s">                          = \frac{ (E_{i+1}(1+\omega)+E_{i+1} }</span>
<span class="s">                                  { (E_i(1+\omega)+E_i }</span>
<span class="s">                          = \frac{E_{i+1}}{E_i}</span>
<span class="s">                          = \frac{E_i(1+\omega)}{E_i} = 1 + \omega</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="mf">0</span><span class="p">]:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">/</span><span class="n">L</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1</span>
        <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">dLoL</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">/</span><span class="n">L</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">dLoL</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="mf">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="n">dLoL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hstack</span><span class="p">((</span><span class="n">E</span><span class="p">,</span><span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="divergence"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.divergence">[docs]</a><span class="k">def</span> <span class="nf">divergence</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">sample_width</span><span class="o">=</span><span class="mf">1e10</span><span class="p">,</span> <span class="n">sample_broadening</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;</span>
<span class="s">    Calculate divergence due to slit and sample geometry.</span>

<span class="s">    :Parameters:</span>
<span class="s">        *T*         : float OR [float] | degrees</span>
<span class="s">            incident angles</span>
<span class="s">        *slits*     : float OR (float,float) | mm</span>
<span class="s">            s1,s2 slit openings for slit 1 and slit 2</span>
<span class="s">        *distance*  : (float,float) | mm</span>
<span class="s">            d1,d2 distance from sample to slit 1 and slit 2</span>
<span class="s">        *sample_width*      : float | mm</span>
<span class="s">            w, width of the sample</span>
<span class="s">        *sample_broadening* : float | degrees FWHM</span>
<span class="s">            additional divergence caused by sample</span>

<span class="s">    :Returns:</span>
<span class="s">        *dT*  : float OR [float] | degrees FWHM</span>
<span class="s">            calculated angular divergence</span>

<span class="s">    **Algorithm:**</span>

<span class="s">    The divergence is based on the slit openings and the distance between</span>
<span class="s">    the slits.  For very small samples, where the slit opening is larger</span>
<span class="s">    than the width of the sample across the beam, the sample itself acts</span>
<span class="s">    like the second slit.</span>

<span class="s">    First find $p$, the projection of the beam on the sample:</span>

<span class="s">    .. math::</span>

<span class="s">        p &amp;= w \sin\left(\frac{\pi}{180}\theta\right)</span>

<span class="s">    Depending on whether $p$ is larger than $s_2$, determine the slit</span>
<span class="s">    divergence $\Delta\theta_d$ in radians:</span>

<span class="s">    .. math::</span>

<span class="s">        \Delta\theta_d &amp;= \left\{</span>
<span class="s">          \begin{array}{ll}</span>
<span class="s">            \frac{1}{2}\frac{s_1+s_2}{d_1-d_2} &amp; \mbox{if } p \geq s_2 \\</span>
<span class="s">            \frac{1}{2}\frac{s_1+p}{d_1}       &amp; \mbox{if } p &lt; s_2</span>
<span class="s">          \end{array}</span>
<span class="s">        \right.</span>

<span class="s">    In addition to the slit divergence, we need to add in any sample</span>
<span class="s">    broadening $\Delta\theta_s$ returning the total divergence in degrees:</span>

<span class="s">    .. math::</span>

<span class="s">        \Delta\theta &amp;= \frac{180}{\pi} \Delta\theta_d + \Delta\theta_s</span>

<span class="s">    Reversing this equation, the sample broadening contribution can</span>
<span class="s">    be measured from the full width at half maximum of the rocking</span>
<span class="s">    curve, $B$, measured in degrees at a particular angle and slit</span>
<span class="s">    opening:</span>

<span class="s">    .. math::</span>

<span class="s">        \Delta\theta_s = B - \frac{180}{\pi}\Delta\theta_d</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: check that the formula is correct for T=0 =&gt; dT = s1 / d1</span>
    <span class="c"># TODO: add sample_offset and compute full footprint</span>
    <span class="n">d1</span><span class="p">,</span><span class="n">d2</span> <span class="o">=</span> <span class="n">distance</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="o">=</span> <span class="n">slits</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">s1</span><span class="o">=</span><span class="n">s2</span> <span class="o">=</span> <span class="n">slits</span>

    <span class="c"># Compute FWHM angular divergence dT from the slits in degrees</span>
    <span class="n">dT</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">s1</span><span class="o">+</span><span class="n">s2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">d1</span><span class="o">-</span><span class="n">d2</span><span class="p">))</span>

    <span class="c"># For small samples, use the sample projection instead.</span>
    <span class="n">sample_s</span> <span class="o">=</span> <span class="n">sample_width</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">sample_s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_s</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">:</span> <span class="n">dT</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">s1</span><span class="o">+</span><span class="n">sample_s</span><span class="p">)</span><span class="o">/</span><span class="n">d1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">sample_s</span> <span class="o">&lt;</span> <span class="n">s2</span>
        <span class="c">#print s1,s2,d1,d2,T,dT,sample_s</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">sample_s</span><span class="p">)</span><span class="o">*</span><span class="n">s1</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">sample_s</span><span class="p">)</span><span class="o">*</span><span class="n">dT</span>
        <span class="n">dT</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">sample_s</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">/</span><span class="n">d1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dT</span> <span class="o">+</span> <span class="n">sample_broadening</span>
</div>
<div class="viewcode-block" id="slit_widths"><a class="viewcode-back" href="../../api/resolution.html#refl1d.resolution.slit_widths">[docs]</a><span class="k">def</span> <span class="nf">slit_widths</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">slits_at_Tlo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">Tlo</span><span class="o">=</span><span class="mf">90</span><span class="p">,</span><span class="n">Thi</span><span class="o">=</span><span class="mf">90</span><span class="p">,</span>
                  <span class="n">slits_below</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">slits_above</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the slit widths for the standard scanning reflectometer</span>
<span class="sd">    fixed-opening-fixed geometry.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *T* : [float] | degrees</span>
<span class="sd">            Specular measurement angles.</span>
<span class="sd">        *Tlo*, *Thi* : float | degrees</span>
<span class="sd">            Start and end of the opening region.  The default if *Tlo* is</span>
<span class="sd">            not specified is to use fixed slits at *slits_below* for all</span>
<span class="sd">            angles.</span>
<span class="sd">        *slits_below*, *slits_above* : float OR [float,float] | mm</span>
<span class="sd">            Slits outside opening region.  The default is to use the</span>
<span class="sd">            values of the slits at the ends of the opening region.</span>
<span class="sd">        *slits_at_Tlo* : float OR [float,float] | mm</span>
<span class="sd">            Slits at the start of the opening region.</span>

<span class="sd">    :Returns:</span>
<span class="sd">        *s1*, *s2* : [float] | mm</span>
<span class="sd">            Slit widths for each theta.</span>

<span class="sd">    Slits are assumed to be fixed below angle *Tlo* and above angle *Thi*,</span>
<span class="sd">    and opening at a constant dT/T between them.</span>

<span class="sd">    Slit openings are defined by a tuple (s1,s2) or constant s=s1=s2.</span>
<span class="sd">    With no *Tlo*, the slits are fixed with widths defined by *slits_below*,</span>
<span class="sd">    which defaults to *slits_at_Tlo*.  With no *Thi*, slits are continuously</span>
<span class="sd">    opening above *Tlo*.</span>

<span class="sd">    .. Note::</span>
<span class="sd">         This function works equally well if angles are measured in</span>
<span class="sd">         radians and/or slits are measured in inches.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Slits at T&lt;Tlo</span>
    <span class="k">if</span> <span class="n">slits_below</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">slits_below</span> <span class="o">=</span> <span class="n">slits_at_Tlo</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b1</span><span class="p">,</span><span class="n">b2</span> <span class="o">=</span> <span class="n">slits_below</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">b1</span><span class="o">=</span><span class="n">b2</span> <span class="o">=</span> <span class="n">slits_below</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span>

    <span class="c"># Slits at Tlo&lt;=T&lt;=Thi</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">m1</span><span class="p">,</span><span class="n">m2</span> <span class="o">=</span> <span class="n">slits_at_Tlo</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">m1</span><span class="o">=</span><span class="n">m2</span> <span class="o">=</span> <span class="n">slits_at_Tlo</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Tlo</span>
    <span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">/</span><span class="n">Tlo</span>
    <span class="n">s2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">*</span> <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">/</span><span class="n">Tlo</span>

    <span class="c"># Slits at T &gt; Thi</span>
    <span class="k">if</span> <span class="n">slits_above</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">slits_above</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">Thi</span><span class="o">/</span><span class="n">Tlo</span><span class="p">,</span> <span class="n">m2</span> <span class="o">*</span> <span class="n">Thi</span><span class="o">/</span><span class="n">Tlo</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">t1</span><span class="p">,</span><span class="n">t2</span> <span class="o">=</span> <span class="n">slits_above</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">t1</span><span class="o">=</span><span class="n">t2</span> <span class="o">=</span> <span class="n">slits_above</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Thi</span>
    <span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">s2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">t2</span>

    <span class="k">return</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span>

</div>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def resolution(Q=None,s=None,d=None,L=None,dLoL=None,Tlo=None,Thi=None,</span>
<span class="sd">               s_below=None, s_above=None,</span>
<span class="sd">               broadening=0, sample_width=1e10, sample_distance=0):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Compute the resolution for Q on scanning reflectometers.</span>

<span class="sd">    broadening is the sample warp contribution to angular divergence, as</span>
<span class="sd">    measured by a rocking curve.  The value should be w - (s1+s2)/(2*d)</span>
<span class="sd">    where w is the full-width at half maximum of the rocking curve.</span>

<span class="sd">    For itty-bitty samples, provide a sample width w and sample distance ds</span>
<span class="sd">    from slit 2 to the sample.  If s_sample = sin(T)*w is smaller than s2</span>
<span class="sd">    for some T, then that will be used for the calculation of dT instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    T = QL2T(Q=Q,L=L)</span>
<span class="sd">    slits = slit_widths(T=T, s=s, Tlo=Tlo, Thi=Thi)</span>
<span class="sd">    dT = divergence(T=T,slits=slits, sample_width=sample_width,</span>
<span class="sd">                    sample_distance=sample_distance) + broadening</span>
<span class="sd">    Q,dQ = Qresolution(L, dLoL*L, T, dT)</span>
<span class="sd">    return FWHM2sigma(dQ)</span>

<span class="sd">def demo():</span>
<span class="sd">    import pylab</span>
<span class="sd">    from numpy import linspace, exp, real, conj, sin, radians</span>
<span class="sd">    # Values from volfrac example in garefl</span>
<span class="sd">    T = linspace(0,9,140)</span>
<span class="sd">    Q = 4*pi*sin(radians(T))/5.0042</span>
<span class="sd">    dQ = resolution(Q,s=0.21,Tlo=0.35,d=1890.,L=5.0042,dLoL=0.009)</span>
<span class="sd">    #pylab.plot(Q,dQ)</span>

<span class="sd">    # Fresnel reflectivity for silicon</span>
<span class="sd">    rho,sigma=2.07,5</span>
<span class="sd">    kz=Q/2</span>
<span class="sd">    f = sqrt(kz**2 - 4*pi*rho*1e-6 + 0j)</span>
<span class="sd">    r = (kz-f)/(kz+f)*exp(-2*sigma**2*kz*f)</span>
<span class="sd">    r[abs(kz)&lt;1e-10] = -1</span>
<span class="sd">    R = real(r*conj(r))</span>
<span class="sd">    pylab.errorbar(Q,R,xerr=dQ,fmt=&#39;,r&#39;,capsize=0)</span>
<span class="sd">    pylab.grid(True)</span>
<span class="sd">    pylab.semilogy(Q,R,&#39;,b&#39;)</span>

<span class="sd">    pylab.show()</span>

<span class="sd">def demo2():</span>
<span class="sd">    import numpy,pylab</span>
<span class="sd">    Q,R,dR = numpy.loadtxt(&#39;ga128.refl.mce&#39;).T</span>
<span class="sd">    dQ = resolution(Q, s=0.154, Tlo=0.36, d=1500., L=4.75, dLoL=0.02)</span>
<span class="sd">    pylab.errorbar(Q,R,xerr=dQ,yerr=dR,fmt=&#39;,r&#39;,capsize=0)</span>
<span class="sd">    pylab.grid(True)</span>
<span class="sd">    pylab.semilogy(Q,R,&#39;,b&#39;)</span>
<span class="sd">    pylab.show()</span>



<span class="sd">if __name__ == &quot;__main__&quot;:</span>
<span class="sd">    demo2()</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2006-2011, Paul Kienzle, Nikunj Patel, James Krycka.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>