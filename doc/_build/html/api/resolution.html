

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refl1d.resolution - Resolution &mdash; Refl1D v0.6.19 documentation</title>
    <link rel="stylesheet" href="../_static/haiku-site.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.6.19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/MathJax/MathJax.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Refl1D v0.6.19 documentation" href="../index.html" />
    <link rel="up" title="Reference" href="index.html" />
    <link rel="next" title="refl1d.simplex - Nelder-Mead simplex optimizer (amoeba)" href="simplex.html" />
    <link rel="prev" title="refl1d.reflmodule - Low level reflectivity calculations" href="reflmodule.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="../_static/logo.png" alt="Logo"/><h1 class="heading"><a href="../index.html">
          <span>Refl1D v0.6.19 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.resolution - Resolution</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="reflmodule.html">refl1d.reflmodule - Low level reflectivity calculations</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="simplex.html">refl1d.simplex - Nelder-Mead simplex optimizer (amoeba)</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="refl1d-resolution-resolution">
<h1>refl1d.resolution - Resolution<a class="headerlink" href="#refl1d-resolution-resolution" title="Permalink to this headline">¶</a></h1>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#refl1d.resolution.FWHM2sigma" title="refl1d.resolution.FWHM2sigma"><tt class="xref py py-obj docutils literal"><span class="pre">FWHM2sigma</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.QL2T" title="refl1d.resolution.QL2T"><tt class="xref py py-obj docutils literal"><span class="pre">QL2T</span></tt></a></td>
<td>Compute angle from <span class="math">Q</span> and wavelength.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.TL2Q" title="refl1d.resolution.TL2Q"><tt class="xref py py-obj docutils literal"><span class="pre">TL2Q</span></tt></a></td>
<td>Compute <span class="math">Q</span> from angle and wavelength.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.TOF2L" title="refl1d.resolution.TOF2L"><tt class="xref py py-obj docutils literal"><span class="pre">TOF2L</span></tt></a></td>
<td>Convert neutron time-of-flight to wavelength.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.binedges" title="refl1d.resolution.binedges"><tt class="xref py py-obj docutils literal"><span class="pre">binedges</span></tt></a></td>
<td>Construct bin edges <em>E</em> from bin centers <em>L</em>.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.bins" title="refl1d.resolution.bins"><tt class="xref py py-obj docutils literal"><span class="pre">bins</span></tt></a></td>
<td>Return bin centers from low to high preserving a fixed resolution.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.binwidths" title="refl1d.resolution.binwidths"><tt class="xref py py-obj docutils literal"><span class="pre">binwidths</span></tt></a></td>
<td>Determine the wavelength dispersion from bin centers <em>L</em>.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.dQdL2dT" title="refl1d.resolution.dQdL2dT"><tt class="xref py py-obj docutils literal"><span class="pre">dQdL2dT</span></tt></a></td>
<td>Convert a calculated Q resolution and wavelength dispersion to</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.dQdT2dLoL" title="refl1d.resolution.dQdT2dLoL"><tt class="xref py py-obj docutils literal"><span class="pre">dQdT2dLoL</span></tt></a></td>
<td>Convert a calculated Q resolution and angular divergence to a</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.dTdL2dQ" title="refl1d.resolution.dTdL2dQ"><tt class="xref py py-obj docutils literal"><span class="pre">dTdL2dQ</span></tt></a></td>
<td>Convert wavelength dispersion and angular divergence to <span class="math">Q</span> resolution.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.divergence" title="refl1d.resolution.divergence"><tt class="xref py py-obj docutils literal"><span class="pre">divergence</span></tt></a></td>
<td>Calculate divergence due to slit and sample geometry.</td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.sigma2FWHM" title="refl1d.resolution.sigma2FWHM"><tt class="xref py py-obj docutils literal"><span class="pre">sigma2FWHM</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#refl1d.resolution.slit_widths" title="refl1d.resolution.slit_widths"><tt class="xref py py-obj docutils literal"><span class="pre">slit_widths</span></tt></a></td>
<td>Compute the slit widths for the standard scanning reflectometer fixed-opening-fixed geometry.</td>
</tr>
</tbody>
</table>
<span class="target" id="module-refl1d.resolution"></span><p>Resolution calculations</p>
<dl class="function">
<dt id="refl1d.resolution.FWHM2sigma">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">FWHM2sigma</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#FWHM2sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.FWHM2sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refl1d.resolution.QL2T">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">QL2T</tt><big>(</big><em>Q=None</em>, <em>L=None</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#QL2T"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.QL2T" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute angle from <span class="math">Q</span> and wavelength.</p>
<div class="math">
\theta = \sin^{-1}( |Q| \lambda / 4 \pi )</div>
<p>Returns <span class="math">\theta</span>°.</p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.TL2Q">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">TL2Q</tt><big>(</big><em>T=None</em>, <em>L=None</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#TL2Q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.TL2Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <span class="math">Q</span> from angle and wavelength.</p>
<div class="math">
Q = 4 \pi \sin(\theta) / \lambda</div>
<p>Returns <span class="math">Q</span> Å<sup>-1</sup></p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.TOF2L">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">TOF2L</tt><big>(</big><em>d_moderator</em>, <em>TOF</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#TOF2L"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.TOF2L" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert neutron time-of-flight to wavelength.</p>
<div class="math">
\lambda = (t/d) (h/n_m)</div>
<p>where:</p>
<blockquote>
<div class="line-block">
<div class="line"><span class="math">\lambda</span> is wavelength in Å</div>
<div class="line"><span class="math">t</span> is time-of-flight in <span class="math">u</span>s</div>
<div class="line"><span class="math">h</span> is Planck&#8217;s constant in erg seconds</div>
<div class="line"><span class="math">n_m</span> is the neutron mass in g</div>
</div>
</blockquote>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.binedges">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">binedges</tt><big>(</big><em>L</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#binedges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.binedges" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct bin edges <em>E</em> from bin centers <em>L</em>.</p>
<p>Assuming fixed <span class="math">\omega = \Delta\lambda/\lambda</span> in the bins, the
edges will be spaced logarithmically at:</p>
<div class="math">
\begin{split}E_0     &amp;= \min \lambda \\
E_{i+1} &amp;= E_i + \omega E_i = E_i (1+\omega)\end{split}</div>
<p>with centers <span class="math">L</span> half way between the edges:</p>
<div class="math">
L_i = (E_i+E_{i+1})/2
    = (E_i + E_i (1+\omega))/2
    = E_i (2 + \omega)/2</div>
<p>Solving for <span class="math">E_i</span>, we can recover the edges from the centers:</p>
<div class="math">
E_i = L_i \frac{2}{2+\omega}</div>
<p>The final edge, <span class="math">E_{n+1}</span>, does not have a corresponding center
<span class="math">L_{n+1}</span> so we must determine it from the previous edge <span class="math">E_n</span>:</p>
<div class="math">
E_{n+1} = L_n \frac{2}{2+\omega}(1+\omega)</div>
<p>The fixed <span class="math">\omega</span> can be retrieved from the ratio of any pair
of bin centers using:</p>
<div class="math">
\frac{L_{i+1}}{L_i} = \frac{ (E_{i+2}+E_{i+1})/2 }{ (E_{i+1}+E_i)/2 }
                  = \frac{ (E_{i+1}(1+\omega)+E_{i+1} }
                          { (E_i(1+\omega)+E_i }
                  = \frac{E_{i+1}}{E_i}
                  = \frac{E_i(1+\omega)}{E_i} = 1 + \omega</div>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.bins">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">bins</tt><big>(</big><em>low</em>, <em>high</em>, <em>dLoL</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#bins"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Return bin centers from low to high preserving a fixed resolution.</p>
<p><em>low</em>, <em>high</em> are the minimum and maximum wavelength.
<em>dLoL</em> is the desired resolution FWHM <span class="math">\Delta\lambda/\lambda</span> for the bins.</p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.binwidths">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">binwidths</tt><big>(</big><em>L</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#binwidths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.binwidths" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the wavelength dispersion from bin centers <em>L</em>.</p>
<p>The wavelength dispersion <span class="math">\Delta\lambda</span> is just the difference
between consecutive bin edges, so:</p>
<div class="math">
\Delta L_i  = E_{i+1}-E_{i}
            = (1+\omega) E_i - E_i
            = \omega E_i
            = \frac{2 \omega}{2+\omega} L_i</div>
<p>where <span class="math">E</span> and <span class="math">\omega</span> are as defined in <a class="reference internal" href="#refl1d.resolution.binedges" title="refl1d.resolution.binedges"><tt class="xref py py-func docutils literal"><span class="pre">binedges()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.dQdL2dT">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">dQdL2dT</tt><big>(</big><em>Q</em>, <em>dQ</em>, <em>L</em>, <em>dL</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#dQdL2dT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.dQdL2dT" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a calculated Q resolution and wavelength dispersion to
angular divergence.</p>
<p><em>Q</em>, <em>dQ</em> Å<sup>-1</sup>  <span class="math">Q</span> and 1-<span class="math">\sigma</span> <span class="math">Q</span> resolution
<em>L</em>, <em>dL</em> ° angle and FWHM angular divergence</p>
<p>Returns FWHM <span class="math">\theta, \Delta\theta</span></p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.dQdT2dLoL">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">dQdT2dLoL</tt><big>(</big><em>Q</em>, <em>dQ</em>, <em>T</em>, <em>dT</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#dQdT2dLoL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.dQdT2dLoL" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a calculated Q resolution and angular divergence to a
wavelength dispersion.</p>
<p><em>Q</em>, <em>dQ</em> Å<sup>-1</sup>  <span class="math">Q</span> and 1-<span class="math">\sigma</span> <span class="math">Q</span> resolution
<em>T</em>, <em>dT</em> ° angle and FWHM angular divergence</p>
<p>Returns FWHM <span class="math">\Delta\lambda/\lambda</span></p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.dTdL2dQ">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">dTdL2dQ</tt><big>(</big><em>T=None</em>, <em>dT=None</em>, <em>L=None</em>, <em>dL=None</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#dTdL2dQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.dTdL2dQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert wavelength dispersion and angular divergence to <span class="math">Q</span> resolution.</p>
<p><em>T</em>,*dT*  (degrees) angle and FWHM angular divergence
<em>L</em>,*dL*  (Angstroms) wavelength and FWHM wavelength dispersion</p>
<p>Returns 1-<span class="math">\sigma</span> <span class="math">\Delta Q</span></p>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.divergence">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">divergence</tt><big>(</big><em>T=None</em>, <em>slits=None</em>, <em>distance=None</em>, <em>sample_width=10000000000.0</em>, <em>sample_broadening=0</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#divergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.divergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate divergence due to slit and sample geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><dl class="first docutils">
<dt><em>T</em> <span class="classifier-delimiter">:</span> <span class="classifier">float OR [float] | degrees</span></dt>
<dd><p class="first last">incident angles</p>
</dd>
<dt><em>slits</em> <span class="classifier-delimiter">:</span> <span class="classifier">float OR (float,float) | mm</span></dt>
<dd><p class="first last">s1,s2 slit openings for slit 1 and slit 2</p>
</dd>
<dt><em>distance</em> <span class="classifier-delimiter">:</span> <span class="classifier">(float,float) | mm</span></dt>
<dd><p class="first last">d1,d2 distance from sample to slit 1 and slit 2</p>
</dd>
<dt><em>sample_width</em> <span class="classifier-delimiter">:</span> <span class="classifier">float | mm</span></dt>
<dd><p class="first last">w, width of the sample</p>
</dd>
<dt><em>sample_broadening</em> <span class="classifier-delimiter">:</span> <span class="classifier">float | degrees FWHM</span></dt>
<dd><p class="first last">additional divergence caused by sample</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><dl class="first last docutils">
<dt><em>dT</em> <span class="classifier-delimiter">:</span> <span class="classifier">float OR [float] | degrees FWHM</span></dt>
<dd><p class="first last">calculated angular divergence</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p><strong>Algorithm:</strong></p>
<p>The divergence is based on the slit openings and the distance between
the slits.  For very small samples, where the slit opening is larger
than the width of the sample across the beam, the sample itself acts
like the second slit.</p>
<p>First find <span class="math">p</span>, the projection of the beam on the sample:</p>
<div class="math">
\begin{split}p &amp;= w \sin\left(\frac{\pi}{180}\theta\right)\end{split}</div>
<p>Depending on whether <span class="math">p</span> is larger than <span class="math">s_2</span>, determine the slit
divergence <span class="math">\Delta\theta_d</span> in radians:</p>
<div class="math">
\begin{split}\Delta\theta_d &amp;= \left\{
  \begin{array}{ll}
    \frac{1}{2}\frac{s_1+s_2}{d_1-d_2} &amp; \mbox{if } p \geq s_2 \\
    \frac{1}{2}\frac{s_1+p}{d_1}       &amp; \mbox{if } p &lt; s_2
  \end{array}
\right.\end{split}</div>
<p>In addition to the slit divergence, we need to add in any sample
broadening <span class="math">\Delta\theta_s</span> returning the total divergence in degrees:</p>
<div class="math">
\begin{split}\Delta\theta &amp;= \frac{180}{\pi} \Delta\theta_d + \Delta\theta_s\end{split}</div>
<p>Reversing this equation, the sample broadening contribution can
be measured from the full width at half maximum of the rocking
curve, <span class="math">B</span>, measured in degrees at a particular angle and slit
opening:</p>
<div class="math">
\Delta\theta_s = B - \frac{180}{\pi}\Delta\theta_d</div>
</dd></dl>

<dl class="function">
<dt id="refl1d.resolution.sigma2FWHM">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">sigma2FWHM</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#sigma2FWHM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.sigma2FWHM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refl1d.resolution.slit_widths">
<tt class="descclassname">refl1d.resolution.</tt><tt class="descname">slit_widths</tt><big>(</big><em>T=None</em>, <em>slits_at_Tlo=None</em>, <em>Tlo=90</em>, <em>Thi=90</em>, <em>slits_below=None</em>, <em>slits_above=None</em><big>)</big><a class="reference internal" href="../_modules/refl1d/resolution.html#slit_widths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refl1d.resolution.slit_widths" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the slit widths for the standard scanning reflectometer
fixed-opening-fixed geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><dl class="first docutils">
<dt><em>T</em> <span class="classifier-delimiter">:</span> <span class="classifier">[float] | degrees</span></dt>
<dd><p class="first last">Specular measurement angles.</p>
</dd>
<dt><em>Tlo</em>, <em>Thi</em> <span class="classifier-delimiter">:</span> <span class="classifier">float | degrees</span></dt>
<dd><p class="first last">Start and end of the opening region.  The default if <em>Tlo</em> is
not specified is to use fixed slits at <em>slits_below</em> for all
angles.</p>
</dd>
<dt><em>slits_below</em>, <em>slits_above</em> <span class="classifier-delimiter">:</span> <span class="classifier">float OR [float,float] | mm</span></dt>
<dd><p class="first last">Slits outside opening region.  The default is to use the
values of the slits at the ends of the opening region.</p>
</dd>
<dt><em>slits_at_Tlo</em> <span class="classifier-delimiter">:</span> <span class="classifier">float OR [float,float] | mm</span></dt>
<dd><p class="first last">Slits at the start of the opening region.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><dl class="first last docutils">
<dt><em>s1</em>, <em>s2</em> <span class="classifier-delimiter">:</span> <span class="classifier">[float] | mm</span></dt>
<dd><p class="first last">Slit widths for each theta.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Slits are assumed to be fixed below angle <em>Tlo</em> and above angle <em>Thi</em>,
and opening at a constant dT/T between them.</p>
<p>Slit openings are defined by a tuple (s1,s2) or constant s=s1=s2.
With no <em>Tlo</em>, the slits are fixed with widths defined by <em>slits_below</em>,
which defaults to <em>slits_at_Tlo</em>.  With no <em>Thi</em>, slits are continuously
opening above <em>Tlo</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function works equally well if angles are measured in
radians and/or slits are measured in inches.</p>
</div>
</dd></dl>

</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="reflmodule.html">refl1d.reflmodule - Low level reflectivity calculations</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="simplex.html">refl1d.simplex - Nelder-Mead simplex optimizer (amoeba)</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2006-2011, Paul Kienzle, Nikunj Patel, James Krycka.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>